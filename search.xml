<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Rust之函数与集合</title>
    <url>/2020/03/04/Rust%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="Rust之函数与集合"><a href="#Rust之函数与集合" class="headerlink" title="Rust之函数与集合"></a>Rust之函数与集合</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是几乎每一个编程语言都有的一个概念，近些年随着计算机技术的发展，多核的CPU使得人们对并发的要求越来越高，而函数式编程因为其天生对并发支持就好的特点，导致函数式的编程范式越来越被重视。函数式编程起源于非常古老的语言Lisp，Lisp是第二个高级编程语言，比C的历史更早，后世的很多函数式语言都收到其影响。而因为函数式编程范式的开始流行，很多主流语言开始加入函数式编程的特点，例如C++和Java。而Rust是一门比较新的语言，当然在语言级别上就支持函数式的编程范式。</p>
<h3 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h3><p>函数的定义是由函数签名和函数体组成的，trait里也可以没有函数体。函数有关键字<strong>fn</strong>定义，紧接着是函数名，函数名的命名规则应遵循蛇形命名法，否则编译器会给出警告。接着是函数的参数列表(当然中间有可能有生命周期参数)，参数列表的顺序，参数的类型都是不可缺少的，主要注意的是，有的语言在参数列表中可以指定默认值，但是在Rust中这是不被允许的。如果有返回值则要指明返回值类型，函数体由花括号包裹，函数体的最后一句表达式即为函数的返回值。一般来说，函数命名不允许使用关键字，但是可以使用<code>r#</code>作为前缀用关键字命名，如：<code>fn r#match(...)...</code>；函数的参数默认是不可变的，也可以使用可变的参数，如<code>fn xx(mut x: i32) -&gt; xxx{...}</code>或者<code>fn xx(x: &amp;mut [i32]) -&gt; i32{}</code>。</p>
<h3 id="函数屏蔽"><a href="#函数屏蔽" class="headerlink" title="函数屏蔽"></a>函数屏蔽</h3><p>变量存在变量遮蔽，函数的声明也存在遮蔽，但是和变量的有些不同。变量的遮蔽使得同名变量在任何情况下都可以声明，但是函数不行，<strong>同一级</strong>(不是同一个)作用域下函数不能重名，而在次级作用域下声明的同名函数会在其作用域下遮蔽其更大一级的作用域的同名函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>()&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个函数声明会报错</span></span><br><span class="line">    <span class="comment">// fn test()&#123;</span></span><br><span class="line">    <span class="comment">//     println!("1-2");</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h3 id="函数参数的通配符"><a href="#函数参数的通配符" class="headerlink" title="函数参数的通配符"></a>函数参数的通配符</h3><p>Rust的函数的参数列表也是支持模式匹配的，但是有时候实现某个trait时，并不需要这个trait的某个函数的全部参数，这时可以使用下划线通配符来忽略参数列表中某些位置上的参数。<code>fn xx(_: i32, a:i32) -&gt; i32</code></p>
<h3 id="return提前返回"><a href="#return提前返回" class="headerlink" title="return提前返回"></a>return提前返回</h3><p>有时需要在发生某种情况下提前返回，这时候就需要用到其他语言里很常见的<code>return</code>语句，例如递归中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辗转相除法求最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gcd</span></span>(a: <span class="built_in">u32</span> , b:<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gcd2</span></span>(a: <span class="built_in">u32</span> , b:<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123; a &#125;<span class="keyword">else</span>&#123; gcd2(b, a%b) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">16</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"gcd : &#123;&#125;, gcd2 : &#123;&#125;"</span>, gcd(x,y),gcd2(x,y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>在计算机术语里，高阶函数指的是以函数作为参数或者返回值的函数，在函数式语言里，函数和值类型一样是一等公民，可以被当作参数传递或者当作返回值返回，这时函数式编程的最基本的特点。Rust支持函数式编程，所以函数在Rust也是一种类型，不同的是函数的类型就是函数本身，即使是相同参数列表，返回值的两个函数，它们的类型也是不同的，只要是连个不同的函数，它们的类型就是不同的，那么怎么实现函数作为参数或者返回值呢？就是使用函数指针，函数指针也是一种类型，只不过与函数类型不同，函数指针的类型取决于参数和返回值，只要相同参数列表和返回值类型的函数指针就是同一类型，函数类型的值可以转化为函数指针类型的值，这样就可以把函数作为参数和返回值。编译器可以自动转化，不用手动转化。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数指针类型的别名</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">MyFun</span></span> = <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test1</span></span>(x:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test2</span></span>(x:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,x+<span class="number">1</span>);</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_fn</span></span>(f:MyFun, x: <span class="built_in">i32</span>) -&gt;<span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, f);</span><br><span class="line">    f(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_fn2</span></span>() -&gt; MyFun &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">xx</span></span>(i: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        i+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    xx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x = test1;</span><br><span class="line">    <span class="keyword">let</span> y: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> = test2;</span><br><span class="line">    <span class="comment">//println!("&#123;:p&#125;",x);报错，因为x是函数类型而不是函数指针类型所以不能打印</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"**********"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, test_fn(x,<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,test_fn(y,<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"**********"</span>);</span><br><span class="line">    <span class="keyword">let</span> f = test_fn2();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//0x401990</span></span><br><span class="line"><span class="comment">//**********</span></span><br><span class="line"><span class="comment">//0x4018f0</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//0x401990</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//**********</span></span><br><span class="line"><span class="comment">//0x401b40</span></span><br></pre></td></tr></table></figure>

<p>可以从上面的代码看出，当使用编译器的类型推断时，函数变量类型为函数类型，当显式指定函数指针类型时，函数变量变成了函数指针类型；并且在函数里类型的变量传入另一个函数时，传递的是指针，并且不需要显式转换，返回值也是函数指针类型。<strong>可以使用关键字type对一个函数指针类型重命名，使用起来更加简洁方便</strong>。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>一个函数之外的能定义的变量对于这个函数来说是自由变量，当函数内用到了自由变量那么函数会将自由变量捕获，与这个变量组合在一起，这种函数叫做闭包。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>(x:<span class="built_in">i32</span>) -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="keyword">move</span> | n | &#123; n+x &#125;;</span><br><span class="line">    v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = test(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> v2 = test(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"v1: &#123;&#125; , v1-2: &#123;&#125; , v2: &#123;&#125;"</span>, v1(<span class="number">1</span>),v1(<span class="number">1</span>),v2(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//v1: 3 , v1-2: 3 , v2: 4</span></span><br></pre></td></tr></table></figure>

<p>move将自由变量强制移给闭包。闭包实际上是一种特殊的匿名函数，它的参数类型和返回值类型都能够推断，使用起来和函数没有什么大的区别。闭包实际上是trait的语法糖，闭包表达式会被编译器自动翻译成结构体实例，并且为其实现Fn，FnMut，FnOnce三个特质中的一个：</p>
<ul>
<li>Fn，表示闭包以不可变借用的方式捕获自由变量，该闭包没有改变环境的能力，并且可以多次调用，对应&amp;self</li>
<li>FnMut，表示闭包以可变借用的方式捕获自由变量，该闭包可以改变环境，可以多次调用，对应&amp;mut self</li>
<li>FnOnce，表示闭包通过转移所有权来捕获自由变量，该闭包没有改变环境的能力，而且只能使用一次并消耗掉自身，对应self</li>
</ul>
<p>根据自由变量的类型决定实现哪一个特质：</p>
<ul>
<li>若自由变量为复制语义类型，则实现Fn特质</li>
<li>若自由变量为移动语义类型，则实现FnOnce特质</li>
<li>对于可变绑定，并且在闭包中修改了自由变量的值，则实现FnMut特质</li>
</ul>
<p>这三个特质关系是：Fn特质继承FnMut特质，FnMut特质继承FnOnce特质</p>
<p>复制语义实现Fn：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">"xsd"</span>;</span><br><span class="line">    <span class="keyword">let</span> f = || &#123; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x); x&#125;;</span><br><span class="line">    <span class="keyword">let</span> s1 = f();</span><br><span class="line">    <span class="keyword">let</span> s2 = f();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//xsd</span></span><br><span class="line"><span class="comment">//xsd</span></span><br><span class="line"><span class="comment">//xsd</span></span><br><span class="line"><span class="comment">//xsd</span></span><br></pre></td></tr></table></figure>

<p>字符串字面量x是复制语义，则实现Fn特质，闭包f可以调用多次，并且x还能够继续使用</p>
<p>移动语义实现FnOnce：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">"xsd"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> c = || s;</span><br><span class="line">    <span class="keyword">let</span> x = c();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">    <span class="comment">//println!("&#123;&#125;", s);报错，因为s已经没有所有权，不能访问</span></span><br><span class="line">    <span class="comment">//let x1 = c();报错，因为所有权现在在x上，闭包已经再不能使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//xsd</span></span><br></pre></td></tr></table></figure>

<p>可变借用实现FnMut：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = || &#123;s+=<span class="number">1</span>;&#125;;</span><br><span class="line">    f();</span><br><span class="line">    <span class="comment">//println!("&#123;&#125;", s);报错，可变借用期间所有者不能访问资源</span></span><br><span class="line">    f();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>闭包f进行了可变借用，因为下面还用到了闭包f，所以中间的打印s的语句仍然是可变借用作用域内，根据所有权借用规则，可变借用期间拥有者不能访问资源。</p>
<p><strong>最开始的例子中的move关键字虽然是强制将自由变量转移给闭包，但是若自由变量是复制语义，则闭包里的自由变量只是对外边的自由变量的复制，外面的自由变量仍然拥有所有权；当自由变量为移动类型，则所有权会转移到闭包内</strong>。</p>
<p>闭包和函数一样，每一个闭包都是一个独立的类型，而函数通过函数指针类型解决了函数作为参数和返回值的问题，而闭包则是通过trait对象来解决的，因为闭包是通过实现前面所说的三个trait的结构体。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">boxed_closure</span></span>(c:&amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Fn</span>()&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">"second"</span>;</span><br><span class="line">    c.push(<span class="built_in">Box</span>::new(|| &#123;<span class="built_in">println!</span>(<span class="string">"first"</span>);&#125;));</span><br><span class="line">    c.push(<span class="built_in">Box</span>::new(<span class="keyword">move</span> || &#123;<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);&#125;));</span><br><span class="line">    c.push(<span class="built_in">Box</span>::new(|| &#123;<span class="built_in">println!</span>(<span class="string">"third"</span>);&#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Fn</span>()&gt;&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line">    boxed_closure(&amp;<span class="keyword">mut</span> v);</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> v &#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//first</span></span><br><span class="line"><span class="comment">//second</span></span><br><span class="line"><span class="comment">//third</span></span><br></pre></td></tr></table></figure>



<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>字符串并不属于集合，但是也是极为常用的数据结构，互联网的一大部分信息都是以字符串形式传递的。计算机只能存储二进制，传递信息的信号也是二进制表示的，所以字符与二进制数之间存在某种映射关系，这种映射关系叫做<strong>字符编码</strong>。很多中自然语言都有自己的编码集，如英语的ASCII码，中文的GBK等等，为了传输信息的正确性，需要在计算机上安装多套字符编码集，编解码时还需要来回切换，很不方便，于是就出现了Unicode，包含了世界上所有语言的字符，每一个字符对应一个非负整数，这个非负整数叫做<strong>码点</strong>。但是由于字符数量太多，需要4个字节的空间存储一个码点，这样传输效率太低，于是需要解决其存储空间太大的问题，就采用了<strong>码元</strong>组成的序列的存储方式。Unicode的字符编码表分为UTF-8，UTF-16，UTF-32，它们的码元依次为1，2，4个字节，其中UTF-8的使用最为广泛。</p>
<p>在Rust中，字符类型用char表示，char类型的量对应了其Unicode的码点，所以char类型是4个字节，这和其他很多编程语言都不一样。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="built_in">char</span>::*;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> c = <span class="string">'罪'</span>;</span><br><span class="line">    <span class="keyword">let</span> c_u32 = c <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:x&#125;"</span>, c_u32);</span><br><span class="line">    <span class="keyword">match</span> from_u32(c_u32) &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="string">'罪'</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'罪'</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"None"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//罪</span></span><br><span class="line"><span class="comment">//7f6a</span></span><br><span class="line"><span class="comment">//罪</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将字符转化为字符串</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> c = <span class="string">'罪'</span>;</span><br><span class="line">    <span class="keyword">let</span> len = c.len_utf8();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, len);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = [<span class="number">0</span>;<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> ss = c.encode_utf8(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">"罪"</span>, ss);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, ss);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//罪</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符常用方法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="comment">//is_digit,判断字符是否是十六进制或者10进制，根据参数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, <span class="string">'F'</span>.is_digit(<span class="number">16</span>));<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,<span class="string">'f'</span>.is_digit(<span class="number">16</span>));<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,<span class="string">'z'</span>.is_digit(<span class="number">16</span>));<span class="comment">//false</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,<span class="string">'f'</span>.is_digit(<span class="number">10</span>));<span class="comment">//false</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, <span class="string">'9'</span>.is_digit(<span class="number">10</span>));<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//to_digit,将字符转化为十六进制或者十进制</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, <span class="string">'f'</span>.to_digit(<span class="number">16</span>));<span class="comment">//Some(15)</span></span><br><span class="line">    <span class="comment">//is_lowercase,判断字符是否为小写，只有具有Lowercase属性的字符才有此方法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'z'</span>.is_lowercase());<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'Z'</span>.is_lowercase());<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//is_uppercase,判断字符是否为大写，只有具有Uppercase属性的字符才有此方法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'x'</span>.is_uppercase());<span class="comment">//false</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'X'</span>.is_uppercase());<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//to_lowercase,将字符转成小写</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'A'</span>.to_lowercase());<span class="comment">//a</span></span><br><span class="line">    <span class="comment">//to_uppercase,将字符转成大写</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'a'</span>.to_uppercase());<span class="comment">//A</span></span><br><span class="line">    <span class="comment">//is_whitespace,判断字符是否是空格</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'d'</span>.is_whitespace());<span class="comment">//false</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,<span class="string">' '</span>.is_whitespace());<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//println!("&#123;&#125;",''.is_whitespace());报错:空字符?</span></span><br><span class="line">    <span class="comment">//is_alphabetic,判断字符是否是字母(汉字也算)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'罪'</span>.is_alphabetic());<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'a'</span>.is_alphabetic());<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//is_alphanumeric,判断字符是否是数字或者字母</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'罪'</span>.is_alphanumeric());<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'a'</span>.is_alphanumeric());<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'1'</span>.is_alphanumeric());<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//is_numeric,判断字符是否是数字</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'1'</span>.is_numeric());<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'s'</span>.is_numeric());<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//escape_default,用来转义 转义字符</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'\"'</span>.escape_default(),); <span class="comment">//\"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>除了str类型，还有String类型的字符串，String类型是在堆上分配的，实际上是一个结构体，由指向堆中字节序列的指针(as_ptr方法)，记录字节序列的字节长度(len方法)和堆分配的容量(capacity方法)组成。</p>
<ul>
<li>创建string字符串的几种方式</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> string = <span class="built_in">String</span>::new();<span class="comment">//创建空字符串，并未分配堆上空间</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, string);</span><br><span class="line">    <span class="keyword">let</span> string = <span class="built_in">String</span>::from(<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, string);</span><br><span class="line">    <span class="keyword">let</span> string = <span class="built_in">String</span>::from(<span class="string">"xsd"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, string);</span><br><span class="line">    <span class="keyword">let</span> string = <span class="built_in">String</span>::with_capacity(<span class="number">10</span>);<span class="comment">//用于分配指定参数字节数量的堆空间</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, string);</span><br><span class="line">    <span class="keyword">let</span> s: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"xsd"</span>;</span><br><span class="line">    <span class="keyword">let</span> string = string.to_string();<span class="comment">//和to_owned方法一样通过字符串字面量创建String</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, string);</span><br><span class="line">    <span class="keyword">let</span> string = s.to_owned();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>处理字符串的两种方式</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">str</span> = <span class="string">"abcde"</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> chars = <span class="built_in">str</span>.chars();</span><br><span class="line">    <span class="keyword">let</span> l = <span class="built_in">str</span>.len();</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..l &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, chars.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> bytes = <span class="built_in">str</span>.bytes();</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..l &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, bytes.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//Some('a')</span></span><br><span class="line"><span class="comment">//Some('b')</span></span><br><span class="line"><span class="comment">//Some('c')</span></span><br><span class="line"><span class="comment">//Some('d')</span></span><br><span class="line"><span class="comment">//Some('e')</span></span><br><span class="line"><span class="comment">//Some(97)</span></span><br><span class="line"><span class="comment">//Some(98)</span></span><br><span class="line"><span class="comment">//Some(99)</span></span><br><span class="line"><span class="comment">//Some(100)</span></span><br><span class="line"><span class="comment">//Some(101)</span></span><br></pre></td></tr></table></figure>

<p>chars方法返回一个字符串的<strong>字符</strong>迭代器，其next方法按照码位迭代，bytes方法返回<strong>字节</strong>迭代器，其next方法按照字节迭代。</p>
<ul>
<li>追加字符和串，push方法用于追加字符，push_str方法用于追加字符串</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    s.push(<span class="string">','</span>);</span><br><span class="line">    s.push_str(<span class="string">" Rust!"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>插入字符和串，注意，因为是Unicode编码，每个字符占的字节数量不一定相等，insert方法会判断插入位置首否合法，不合法将引发panic，对于ASCII码没有这个问题。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    s.insert(<span class="number">1</span>,<span class="string">'a'</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</span><br><span class="line">    s.insert_str(<span class="number">3</span>,<span class="string">"xsd"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//haello</span></span><br><span class="line"><span class="comment">//haexsdllo</span></span><br></pre></td></tr></table></figure>

<ul>
<li>分割字符串，split_at和split_at_mut方法，和插入一样也需要注意分割的位置是否合法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello,world!"</span>);</span><br><span class="line">    <span class="keyword">let</span> (first,last) = s.split_at(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"f = &#123;&#125; --- l = &#123;&#125;"</span>, first,last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//f = hello, --- l = world!</span></span><br></pre></td></tr></table></figure>

<ul>
<li>连接字符串，注意，加法操作符右边是&amp;str类型，加String时要先取引用</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s1 = <span class="string">"Hello"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="string">"world"</span>.to_string();</span><br><span class="line">    s1 = s1 + <span class="string">", "</span>+ &amp;s2;<span class="comment">//注意相加的要是&amp;str类型，而不是String类型</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s1);</span><br><span class="line">    s1 += <span class="string">"!"</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//Hello, world</span></span><br><span class="line"><span class="comment">//Hello, world!</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除字符</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="string">"xsd"</span>.to_string();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,s.pop());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//Some('d')</span></span><br><span class="line"><span class="comment">//xs</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符存在判断</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s.contains(<span class="string">'H'</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s.contains(<span class="string">'h'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符查找</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">"Hello, 世界"</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, s.find(<span class="string">'l'</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, s.find(<span class="string">'世'</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, s.find(<span class="string">'a'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//Some(2)</span></span><br><span class="line"><span class="comment">//Some(7)</span></span><br><span class="line"><span class="comment">//None</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符和串的替换，replace和replacen方法，参数是字符或者字符串都可以</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">"a a0 ao abc"</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s.replace(<span class="string">"abc"</span>,<span class="string">"def"</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s.replacen(<span class="string">'a'</span>,<span class="string">"A-"</span>,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//a a0 ao def</span></span><br><span class="line"><span class="comment">//A- A-0 ao abc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串转换为数字，注意，因为需要指定泛型的类型，所以需要指定x的类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">u32</span> = <span class="string">"1"</span>.parse().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h3 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h3><p>Rust标准库提供的常用集合有：<code>Vec&lt;T&gt;</code>动态增长的数组，<code>VecDeque&lt;T&gt;</code>双端队列，<code>LinkedList&lt;T&gt;</code>链表，两种散列表<code>HashMap&lt;K,V&gt;</code>和<code>BTreeMap&lt;K,V&gt;</code>，两种集合<code>HashSet&lt;T&gt;</code>和<code>BTreeSet&lt;T&gt;</code>，以及大端堆<code>BinaryHeap&lt;T&gt;</code>。它们都在<code>std::collections::*</code>模块里面，除了Vec不需要引入，其他的集合在使用前都需要引入模块。</p>
<h4 id="Vec"><a href="#Vec" class="headerlink" title="Vec"></a>Vec</h4><p>Vec能够存储的最大元素个数为<code>std::usize::MAX</code>个，超过这个个数会引发panic。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="comment">//创建空Vec</span></span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">Vec</span>::&lt;<span class="built_in">i32</span>&gt;::new();</span><br><span class="line">    <span class="comment">//创建指定初始大小的空Vec</span></span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="built_in">Vec</span>::&lt;<span class="built_in">String</span>&gt;::with_capacity(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//用宏创建Vec并初始化</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v3 = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向Vec添加单个元素</span></span><br><span class="line">    v3.push(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//向Vec添加多个元素</span></span><br><span class="line">    v3.extend_from_slice(&amp;[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]);</span><br><span class="line">    <span class="comment">//向指定位置插入元素</span></span><br><span class="line">    v3.insert(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//弹出末尾元素</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,v3.pop());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, v3);</span><br><span class="line">    <span class="comment">//获取Vec信息</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"capacity=&#123;&#125;, len=&#123;&#125;"</span>, v3.capacity(),v3.len());</span><br><span class="line">    <span class="comment">//下标访问元素</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"v3[2]=&#123;&#125;"</span>, v3[<span class="number">2</span>]);</span><br><span class="line">    v3[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"v3[2]=&#123;&#125;"</span>, v3[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//get下标的访问获取指定元素，返回的是一个Option&lt;T&gt;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = v3.get(<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"i=&#123;&#125;"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取切片</span></span><br><span class="line">    <span class="keyword">let</span> vs = &amp;v3[<span class="number">4</span>..];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, vs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//Some(8)</span></span><br><span class="line"><span class="comment">//[0, 1, 2, 3, 4, 5, 6, 7]</span></span><br><span class="line"><span class="comment">//capacity=12, len=8</span></span><br><span class="line"><span class="comment">//v3[2]=2</span></span><br><span class="line"><span class="comment">//v3[2]=10</span></span><br><span class="line"><span class="comment">//i=6</span></span><br><span class="line"><span class="comment">//[4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>

<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>Map的键需要满足三个条件：</p>
<ol>
<li>自反性。对于任意的a ，a==a</li>
<li>对称性。如果a == b ，则b == a</li>
<li>传递性。如果a == b ，b == c，则 a == c</li>
</ol>
<p>并且需要是能够比较的类型，而且最重要的是要实现Hash特质。在自定义类型时，可以用derive让编译器自动帮我们实现Hash特质。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//derive自动实现Hash，Eq，PartialEq，Debug特质</span></span><br><span class="line"><span class="meta">#[derive(Hash,Eq,PartialEq,Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Person &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="built_in">str</span>,age: <span class="built_in">i32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        Person &#123;</span><br><span class="line">            name : name.to_string(),</span><br><span class="line">            age : age</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="comment">//new方法创建一个空的map</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> m = HashMap::new();</span><br><span class="line">    <span class="comment">//第一次插入时，key和value的类型确定</span></span><br><span class="line">    m.insert(Person::new(<span class="string">"xsd"</span>,<span class="number">14</span>),<span class="string">"13223080865"</span>);</span><br><span class="line">    m.insert(Person::new(<span class="string">"ll"</span>,<span class="number">20</span>),<span class="string">"13777771415"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改指定键的值</span></span><br><span class="line">    <span class="keyword">let</span> p = Person::new(<span class="string">"xsd"</span>,<span class="number">14</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(_) = m.get(&amp;p) &#123;</span><br><span class="line">        m.insert(p,<span class="string">"111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找指定键的值</span></span><br><span class="line">    <span class="keyword">let</span> p = Person::new(<span class="string">"xsd"</span>,<span class="number">14</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(n) = m.get(&amp;p) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,m);</span><br><span class="line">    <span class="comment">//删除指定的键值对</span></span><br><span class="line">    <span class="keyword">let</span> p = Person::new(<span class="string">"ll"</span>,<span class="number">20</span>);</span><br><span class="line">    m.remove(&amp;p);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,m);</span><br><span class="line">    <span class="comment">//判断是否存在指定的键</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"find ll:&#123;&#125;"</span>, m.contains_key(&amp;p));</span><br><span class="line">    <span class="keyword">let</span> p = Person::new(<span class="string">"xsd"</span>,<span class="number">14</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"find xsd:&#123;&#125;"</span>, m.contains_key(&amp;p));</span><br><span class="line">    <span class="comment">//先判断是否存在指定的键，若不存在则插入键和指定的值</span></span><br><span class="line">    m.entry(p).or_insert(<span class="string">"123"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, m);</span><br><span class="line">    <span class="keyword">let</span> p = Person::new(<span class="string">"zs"</span>,<span class="number">99</span>);</span><br><span class="line">    m.entry(p).or_insert(<span class="string">"214356"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//&#123;Person &#123; name: "ll", age: 20 &#125;: "13777771415", Person &#123; name: "xsd", age: 14 &#125;:</span></span><br><span class="line"><span class="comment">//   "13223080865"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;Person &#123; name: "ll", age: 20 &#125;: "13777771415", Person &#123; name: "xsd", age: 14 &#125;: </span></span><br><span class="line"><span class="comment">//   "111"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;Person &#123; name: "xsd", age: 14 &#125;: "111"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//find ll:false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//find xsd:true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;Person &#123; name: "xsd", age: 14 &#125;: "111"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;Person &#123; name: "zs", age: 99 &#125;: "214356", Person &#123; name: "xsd", age: 14 &#125;: "111"&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：不要修改Map中的键！</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器分为内部迭代器和外部迭代器，外部迭代器在外部可以控制整个遍历过程，最常见的for循环就是外部迭代器，而内部迭代器则不能控制遍历过程，只能等其遍历完整个集合。在Rust中的迭代器要指实现Iterator特质，最主要的一个方法就是next方法，返回一个<code>Option&lt;item&gt;</code>。迭代器相比与传统的循环来说，代码的可读性更强，并且各种迭代器可以组合，还可以和各种函数，闭包组合发挥强大的作用。在Rust中的for循环其实就是迭代器的语法糖。</p>
<p>一般来说，<code>iter()</code>创造一个item是&amp;T类型的迭代器，<code>iter_mut()</code>创造一个item是&amp;mut T类型的迭代器，<code>into_iter()</code>创造一个item是T类型的迭代器。</p>
<ul>
<li>迭代Vec</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr.iter() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"&#123;&#125; "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr.iter_mut() &#123;</span><br><span class="line">        *i += <span class="number">1</span>;<span class="comment">//这里要解引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Map集合除了集合都有的iter和iter_mut等方法之外还有keys和value方法返回全部key的迭代器和全部value的迭代器，以及values_mut可变values版本。</p>
<ul>
<li>迭代Map</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> m = HashMap::new();</span><br><span class="line">    m.insert(<span class="number">1</span>,<span class="string">"xsd"</span>);</span><br><span class="line">    m.insert(<span class="number">2</span>,<span class="string">"ll"</span>);</span><br><span class="line">    <span class="keyword">for</span> (k,v) <span class="keyword">in</span> &amp;m &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125; : &#123;&#125;"</span>, k,v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (k,v) <span class="keyword">in</span> m.iter_mut() &#123;</span><br><span class="line">        <span class="comment">//注意解引用</span></span><br><span class="line">        <span class="keyword">if</span> *k == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="comment">//注意解引用</span></span><br><span class="line">            *v = <span class="string">"zs"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//1 : xsd</span></span><br><span class="line"><span class="comment">//2 : ll</span></span><br><span class="line"><span class="comment">//&#123;1: "xsd", 2: "zs"&#125;</span></span><br></pre></td></tr></table></figure>

<p>其他集合的方法大体类似，详情请查看官方文档。</p>
<h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><p>map方法是迭代器最常用额度一个适配器，参数是一个闭包.map本质上是一个结构体，有两个成员，一个是存储元素的迭代器，一个是迭代过程中要执行的函数(就是参数传进来的闭包)，它是惰性的，只有调用其next方法真正迭代的时候，才会执行其方法。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> arr2 = arr.into_iter().map(|x| <span class="number">2</span>*x);</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(x)  =  arr2.next() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//8</span></span><br></pre></td></tr></table></figure>

<p>还有许多适配器，如：</p>
<ol>
<li>Chain，连接两个迭代器创建一个新的迭代器</li>
<li>Cloned，拷贝原始迭代器来创建一个新的迭代器</li>
<li>Filter，过滤元素(有条件判断的)的迭代器</li>
<li>FilterMap，相当于先Filter然后Map组合使用的效果</li>
<li>Fuse，在第一次遍历结果为None时停止迭代</li>
<li>Rev，创建一个反序的迭代器</li>
</ol>
<h3 id="消费器"><a href="#消费器" class="headerlink" title="消费器"></a>消费器</h3><ol>
<li>any，用于寻找容器中是否存在符合条件的元素</li>
<li>fold(在Scala叫reduce)，第一个参数为初始值，第二个参数为一个闭包，闭包有两个参数，第一个参数是一个累加器，第二个参数为迭代器里的值，每次迭代将当前元素作为第二个参数传入闭包结果作为下次迭代的第一个参数，最终的累加器作为返回结果。</li>
<li>collect，收集器，可以将迭代器转化为其他集合类型，包括自定义的集合类型</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::iter::FromIterator;</span><br><span class="line"><span class="comment">//自定义集合类型</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyVec</span></span>(<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;);</span><br><span class="line"><span class="keyword">impl</span> MyVec &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        MyVec(<span class="built_in">Vec</span>::new())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, item:<span class="built_in">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span>.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> FromIterator&lt;<span class="built_in">i32</span>&gt; <span class="keyword">for</span> MyVec &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from_iter</span></span>&lt;I: <span class="built_in">IntoIterator</span>&lt;Item=<span class="built_in">i32</span>&gt;&gt;(iter:I) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> v = MyVec::new();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> iter &#123;</span><br><span class="line">            v.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="comment">//any和fold</span></span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, a.iter().any(|x| x%<span class="number">2</span> == <span class="number">0</span>));<span class="comment">//false</span></span><br><span class="line">    <span class="keyword">let</span> sum = a.iter().fold(<span class="number">0</span>,|acc,x| acc+x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, sum);<span class="comment">//11</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> my = MyVec::new();</span><br><span class="line">    my.add(<span class="number">2</span>);</span><br><span class="line">    my.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将集合转换为自定义集合类型</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">vec!</span>[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].into_iter();</span><br><span class="line">    <span class="keyword">let</span> v = MyVec::from_iter(a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.<span class="number">0</span>, <span class="built_in">vec!</span>[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> v.<span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"&#123;&#125; "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line">    <span class="comment">//两种调用方法都行</span></span><br><span class="line">    <span class="keyword">let</span> a = (<span class="number">0</span>..=<span class="number">5</span>).into_iter();</span><br><span class="line">    <span class="keyword">let</span> v = a.collect::&lt;MyVec&gt;();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.<span class="number">0</span>, <span class="built_in">vec!</span>[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> v.<span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"&#123;&#125; "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//11</span></span><br><span class="line"><span class="comment">//0 1 2 3 4 5</span></span><br><span class="line"><span class="comment">//0 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust之内存管理</title>
    <url>/2020/03/04/Rust%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Rust之内存管理"><a href="#Rust之内存管理" class="headerlink" title="Rust之内存管理"></a>Rust之内存管理</h1><p>程序的运行离不开内存，而不同的语言对于内存管理有着不同的方式。C和C++采用了手动管理内存，由程序员手动调用malloc和free等函数显式管理内存；而其他的大多数语言都采用了自动管理内存-GC，无需开发者手动申请或者释放内存。手动管理内存的优点在于性能，但是由于是人直接操作内存，会带来安全问题。而自动管理内存一般不会造成内存安全问题，但是因为GC的”世界暂停”会导致性能问题。人们常常会根据实际情况的需要采取不同的语言进行开发。而Rust是一门没有GC的语言，但是确实内存安全且高效的语言。</p>
<h2 id="内存管理基础"><a href="#内存管理基础" class="headerlink" title="内存管理基础"></a>内存管理基础</h2><p>程序在运行时所占用内存的虚拟地址空间被分为好几个区域，这些区域被称为<strong>段</strong>。常见的段有：</p>
<ul>
<li>代码段，用于存放编译后的机器码，一般是只读的。</li>
<li>bss段，用于存放未初始化的全局变量和静态变量。</li>
<li>数据段，用于存放有初始化的全局变量和静态变量。</li>
<li>栈段，也叫堆栈，用于存放函数调用所要维护的信息，如函数参数，局部变量，函数调用的上下文等。</li>
<li>堆，存放动态分配内存的区域。</li>
</ul>
<h3 id="变量和函数"><a href="#变量和函数" class="headerlink" title="变量和函数"></a>变量和函数</h3><p>变量分为两种：全局变量和局部变量。全局变量分为常量变量和静态变量，局部变量是指在函数中定义的变量。局部变量会默认被分配到栈上。用const定义的是常量，需显式指定类型，没有固定的地址，生命周期是全局的，会被为编译器在编译期间内联，编译器会对其进行类型检查，所以比宏定义的常量更加安全。静态变量用static定义，也需要显式指定类型，声明周期也是全局的，但是会和程序代码一起被存储到静态存储区。字符串字面量就是静态变量。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针(Pointer)，一个保存有另一个对象的内存空间地址的对象。”segmentation fault”，段错误，对没有权限的内存做一些操作会造成段错误。段错误一般就是由于指针使用不当引发的。关于这类错误，一般由它引发的程序崩溃的地方都不是第一现场，所以这类错误非常难以解决。使用下列指针会引发问题：</p>
<ul>
<li><p>空指针</p>
<p>对空指针解引用会引发错误</p>
</li>
<li><p>野指针</p>
<p>野指针是指未经过初始化的指针，其指向的值是以前遗留下来的数据，会引发bug</p>
</li>
<li><p>悬空指针</p>
<p>指针指向的地址空间已经被释放，这块地址空间已经不属于这个指针，这个指针继续指向这块地址空间，就是悬空指针</p>
</li>
</ul>
<p>等等还有其他的一些情况。</p>
<p>像C那样的指针在Rust中被称为原生指针，形如<code>*const T</code>和<code>*mut T</code>，使用这样的指针是有安全风险的，所以使用它们需要在unsafe代码块中进行，不受Rust编译器的安全检查。引用是一种非空指针，因为它只能由具体的数据对象得来，形如：<code>&amp; T</code>和<code>&amp; mut T</code>，原生指针和引用之间可以通过as操作符互相转换。还有一种指针叫做智能指针，是从C++中引入的。</p>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>智能指针实际上一种结构体，对指针进行了一层封装，实现了Deref和Drop两个特质，Deref提供了解引用的功能，Drop提供了自动析构的能力。Deref是对解引用操作符<code>*</code>的重载，在函数执行完毕，栈帧释放，函数其中的智能指针就会自动执行Drop，做一些清理工作，并不一定就是释放堆内存，还有可能是其他，比如关闭资源等操作。智能指针是基于<strong>RAII</strong>机制实现的，意思是资源获取即初始化。RAII机制是使用构造函数来初始化资源，使用析构函数回收资源。RAII与GC最大的不同是将资源交给堆内存中的指针对象本身去管理，一旦对象生命周期完结，自动调用析构函数回收资源；而GC是第三方来回收垃圾，非常被动。在Rust中，没有构造函数，但是可以自己实现，而Drop就是析构函数。</p>
<ul>
<li>实现Drop特质</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::<span class="built_in">Drop</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span>(<span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> S &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"drop, &#123;&#125;"</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x1 = S(<span class="number">1</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> x2 = S(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"x2 : &#123;:?&#125;"</span>, x2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x1 : &#123;:?&#125;"</span>, x1);</span><br><span class="line">    <span class="comment">//println!("x2 : &#123;:?&#125;", x2);x2已被销毁，不再存在</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//x2 : S(2)</span></span><br><span class="line"><span class="comment">//drop, 2</span></span><br><span class="line"><span class="comment">//x1 : S(1)</span></span><br><span class="line"><span class="comment">//drop, 1</span></span><br></pre></td></tr></table></figure>

<p>从结果看出在超出变量作用域之前，会调用drop函数。对于值传递的类型没有析构函数，变量遮蔽时，变量仍然会在其生命周期内存在，并不会因为变量遮蔽而提前析构。</p>
<p>需要注意的是，不允许手动调用智能指针对象的drop函数，如要想手动析构一个对象，需要调用std::men::drop函数将要释放的指针作为参数传入这个drop函数。</p>
<h5 id="Box指针"><a href="#Box指针" class="headerlink" title="Box指针"></a>Box指针</h5><p><code>Box&lt;T&gt;</code>就是一个智能指针，可以将一个类型的值装箱，例如本来数组1是i32，值类型，默认被分配到栈中，将其用Box装箱后，值就会在堆内存中分配可以通过解引用获取其值，当函数退出，堆内存就会被自动释放。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> box1 = <span class="built_in">Box</span>::new(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">P</span></span> &#123;</span><br><span class="line">        x: <span class="built_in">i32</span>,</span><br><span class="line">        y: <span class="built_in">i32</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bp = <span class="built_in">Box</span>::new(P&#123;x:<span class="number">1</span>,y:-<span class="number">2</span>&#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, *box1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, *bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//P &#123; x: 1, y: -2 &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Box&lt;T&gt;</code>指针是一个用于有所有权的指针堆其赋值执行的永远是move(不仅是引用传递，而且还会交出原变量的所有权)，还有一种可以供多种变量引用的智能指针<code>Rc&lt;T&gt;</code>，引用计数，它会记录下指向同一块内存空间的指针的数量，而且其数据是不可变的。<code>RefCell&lt;T&gt;</code>是其可变版本。</p>
<h2 id="所有权系统"><a href="#所有权系统" class="headerlink" title="所有权系统"></a>所有权系统</h2><p>Box指针是一个拥有所有权的指针，那么什么是所有权？在Rust中，变量对其管理的内存空间具有所有权，并且每一个值都必定有一个唯一的控制者，只有这个控制者才对值代表的内存空间拥有控制权。很多编程语言都把数据类型分为值类型和引用类型，值类型一般是在栈中存储，而引用类型因为更为复杂，所以会将数据存储在堆中，在栈中值保留其在堆中的地址，也就是指针。在Rust叫做值语义和引用语义更为精准。值语义就是复制之后两个数据对象的存储空间是相互独立的，彼此互不影响。引用语义指的是赋值之后，相当于数据对象多了一个别名，操作其中一个，另一个也会改变。一个数据对象拥有数个管理者，这回带来很多安全问题，所以Rust引入了所有权机制。</p>
<p>值语义的类型在复制的时候是按位复制，Rust通过Copy这个trait标记类型是否是按位复制，也就是是否是值语义的类型。引用语义的类型，例如Box指针是一个拥有所有权的指针，是不能够实现Copy特质的。通过Copy特质来区分值语义和引用语义，所以赋值操作也分为复制语义和移动语义。</p>
<p>具有移动语义的类型在复制时会出现所有权的转移。一个值的所有权被转移给另外一个变量绑定的过程叫做所有权转移。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span></span>(<span class="built_in">i32</span>);</span><br><span class="line">    <span class="keyword">let</span> x1 = <span class="built_in">Box</span>::new(S(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> x2 = x1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译出错,因为变量x1对数据的所有权已经转移给了x2，所以之后x1不能再使用</span></span><br><span class="line">error[E0382]: borrow of moved value: `x1`</span><br><span class="line"> --&gt; boxtest2.rs:<span class="number">6</span>:<span class="number">22</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     <span class="keyword">let</span> x1 = <span class="built_in">Box</span>::new(S(<span class="number">1</span>));</span><br><span class="line">  |         -- move occurs because `x1` has type `std::boxed::Box&lt;main::S&gt;`, which does not implement the `Copy` trait</span><br><span class="line"><span class="number">5</span> |     <span class="keyword">let</span> x2 = x1;</span><br><span class="line">  |              -- value moved here</span><br><span class="line"><span class="number">6</span> |     <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x1);</span><br><span class="line">  |                      ^^ value borrowed here after <span class="keyword">move</span></span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br></pre></td></tr></table></figure>

<p>所有权的权限：</p>
<ol>
<li>控制资源(不仅仅是内存)的释放</li>
<li>出借所有权，包括不可变的和可变的</li>
<li>转移所有权</li>
</ol>
<p>结构体和枚举体默认是<strong>移动语义</strong>的，但是可以为其实现Copy和Clone特质变成<strong>复制语义</strong>。而元组默认是复制语义的，但是如果元组的成员存在移动语义的，那么元组将会变成移动语义。</p>
<p>字符串字面量是复制语义的，而字符串(“对象”)则是移动语义的</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"xsd"</span>;</span><br><span class="line">    <span class="keyword">let</span> b = a;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125; , &#123;&#125;"</span>, a,b);<span class="comment">//可以打印出来，a和b是两个2独立的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a1 = <span class="string">"xsd"</span>.to_string();<span class="comment">//报错，a1的所有权已经能够被转移到b1上，a1无法再使用</span></span><br><span class="line">    <span class="keyword">let</span> b1 = a1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125; , &#123;&#125;"</span>, a1,b1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h3><p>引用是一种指针，但与指针不同的是，指针只是单纯的是内存地址，而引用是内存地址的”别名”，使用时要收到编译器的安全检查。引用分为不可变引用&amp;T和可变引用&amp;mut T，引用表示其对所致的那块内存空间没有所有权，所以引用又叫借用。引用在离开其作用域时会的归还其借用。</p>
<p>当发生借用时，所有者会收到如下限制：</p>
<ul>
<li>在不可变借用期间，所有者不能更改资源，并且所有者不能再进行可变借用</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">    age: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = Person&#123;name:<span class="string">"xsd"</span>,age:<span class="number">11</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> x1 = &amp;x;</span><br><span class="line">    <span class="comment">//let mut x2 = &amp;mut x;错误，在发生不可变借用之后，不可以再进行可变借用</span></span><br><span class="line">    <span class="comment">//x.age = 9;错误，不可变借用之后所有者不能更改资源</span></span><br><span class="line">    <span class="keyword">let</span> x2 = &amp;x;<span class="comment">//但是可以进行多次不可变借用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,x2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在可变借用期间，所有者不能访问资源，也不能再进行可变借用</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">    age: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = Person&#123;name:<span class="string">"xsd"</span>,age:<span class="number">14</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> x1 = &amp;<span class="keyword">mut</span> x;<span class="comment">//这个地方let带不带mut都一样，因为x1就是一个可变借用</span></span><br><span class="line">    x1.name = <span class="string">"xxx"</span>;</span><br><span class="line">    <span class="keyword">let</span> x2 = &amp;x;<span class="comment">//错误，进行可变借用之后，不能再进行可变借用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x);<span class="comment">//错误，进行可变借用之后，所有者不能再访问资源</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将上面的x2借用去掉，再将两个打印语句交换位置编译即可通过,因为打印x1之后x1再也没有被使用，所以会归还借用，则x可以访问资源</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">    age: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = Person&#123;name:<span class="string">"xsd"</span>,age:<span class="number">14</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> x1 = &amp;<span class="keyword">mut</span> x;<span class="comment">//这个地方let带不带mut都一样，因为x1就是一个可变借用</span></span><br><span class="line">    x1.name = <span class="string">"xxx"</span>;</span><br><span class="line">    <span class="comment">//let x2 = &amp;x;错误，进行可变借用之后，不能再进行可变借用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//Person &#123; name: "xsd", age: 14 &#125;</span></span><br><span class="line"><span class="comment">//Person &#123; name: "xsd", age: 14 &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="借用规则"><a href="#借用规则" class="headerlink" title="借用规则"></a>借用规则</h4><ol>
<li><p>借用的生命周期不能长于所有者的声明周期,为了防止悬垂指针的出现</p>
</li>
<li><p>可变借用不能有别名，即只能有一个可变借用的变量(<strong>独占</strong>)</p>
</li>
<li><p>不可变借用不能再次出借为可变借用,2和3理解为读写锁，同一时刻，只能拥有一把写锁</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">char</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> data = <span class="built_in">vec!</span>[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">    <span class="keyword">let</span> slice = &amp;<span class="keyword">mut</span> data[..];</span><br><span class="line">    <span class="comment">//data.push('d');push如果放在这里就会报错，因为同一个作用域只能有一个可变借用</span></span><br><span class="line">    cap(slice);</span><br><span class="line">    data.push(<span class="string">'d'</span>);</span><br><span class="line">    data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">cap</span></span>(a: &amp;<span class="keyword">mut</span> [<span class="built_in">char</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a &#123;</span><br><span class="line">        i.make_ascii_uppercase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x = foo();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//['A', 'B', 'C', 'd']</span></span><br></pre></td></tr></table></figure>



<p>另外，<strong>解引用会获得其所有权</strong>，所以在函数内部，不能对外部的引用或者参数引用解引用，因为这样获得其所有权之后，当这个函数返回时，外面所有的引用全部都变成了野指针，所以编译器不允许这么做。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>在函数的签名中带有生命周期参数，主要作用是标注返回值的生命周期，其存在这样的限制：入参的生命周期必须不短于返回值的生命周期。所以在无参函数中不能返回引用，生命周期参数主要用于解决引用跨函数传递的问题。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">str_longest</span></span>&lt;<span class="symbol">'a</span>&gt;(s1: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, s2: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.len() &gt; s2.len() &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"Rust"</span>);</span><br><span class="line">    <span class="keyword">let</span> s1_r = &amp;s1;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"Go"</span>);</span><br><span class="line">        <span class="keyword">let</span> ss = str_longest(s1_r,&amp;s2);<span class="comment">//ss的生命周期小于参数'a，当ss不会变成野指针</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, ss);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若是返回值没有生命周期标记，则函数退出引用就会销毁，无法赋值给变量ss，这是不被编译器允许的。</p>
<p>当有多个不同的生命周期参数时，需要指定它们的大小</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">str_longest</span></span>&lt;<span class="symbol">'a</span>,<span class="symbol">'b</span>:<span class="symbol">'a</span>&gt;(s1: &amp;<span class="symbol">'b</span> <span class="built_in">str</span>, s2: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.len() &gt; s2.len() &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"Rust"</span>);</span><br><span class="line">    <span class="keyword">let</span> s1_r = &amp;s1;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"Go"</span>);</span><br><span class="line">        <span class="keyword">let</span> ss = str_longest(s1_r,&amp;s2);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, ss);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&#39;b: &#39;a</code>的意思是b代表的生命周期长于a，这个例子再次说明了较长生命周期的引用可以赋值给较短生命周期的变量，而反过来不行。这样不容易出现野指针。</li>
</ul>
<h4 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h4><p><code>&#39;static</code>这样的生命周期叫做静态生命周期，这样的数据将会存活于整个程序运行期间，不会被销毁，所有的字符串字面量都是静态生命周期，类型为<code>&amp;&#39;static str</code>，下面的代码可以正确运行，说明字符串字面量是复制语义，而非移动语义。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">"xsd"</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>结构体的生命周期应短于(或等于)任何一个成员的生命周期</strong>。</li>
</ul>
<h4 id="省略生命周期参数"><a href="#省略生命周期参数" class="headerlink" title="省略生命周期参数"></a>省略生命周期参数</h4><p>当在一些情况下，可以省略生命周期参数：</p>
<ul>
<li>当函数参数只有一个参数，返回值的生命周期为参数的生命周期</li>
<li>多个参数都省略，会被分别补上不同的生命周期参数</li>
<li>参在多个生命周期参数的位置，但其中包括&amp;self或&amp;mut self，则返回值的生命周期是self的生命周期</li>
</ul>
<p>当以上都不满足时，就不能省略生命周期参数。</p>
]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust之类型系统</title>
    <url>/2020/03/04/Rust%E4%B9%8B%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="Rust之类型系统"><a href="#Rust之类型系统" class="headerlink" title="Rust之类型系统"></a>Rust之类型系统</h1><p>类型是编程语言不可或缺的一部分，类型系统避免了程序员直接操作二进制数据，使得操作内存更加安全高效。类型系统对于编程语言来说，可以使得编译器能够在编译期间对程序做出检查，提早发现问题，不必等到运行后系统发生崩溃再解决。使得编程语言具备抽象能力，是开发者能够站在更高层次的角度思考，有助于规范和工程化系统，还可以使得程序可读性提升，让编译器可以做一些优化，保证内存的安全性。</p>
<p>在编译期间进行类型检查的语言是静态语言，在运行期间进行类型检查的是动态语言；另外语言还有强类型语言和弱类型语言之分，例如C是静态弱类型的语言，Python是动态强类型语言。但是现在这些概念已经渐渐模糊了，因为语言的特性是在发展变化的。</p>
<h2 id="类型系统和多态"><a href="#类型系统和多态" class="headerlink" title="类型系统和多态"></a>类型系统和多态</h2><p>如果一段代码在不同的上下文中具有不同的类型，这样的类型系统就是多态类型系统。对于静态语言来说，多态型的好处就是可以在不影响类型丰富的前提下，为不同的类型编写通用的代码。现代编程语言包括了三种多态形式：参数化多态，Ad-hoc多态(特定多态)，子类型多态。参数化多态其实就是泛型，类型作为参数，函数的实现与类型无关，多种类型只有一种实现；Ad-hoc多态正好相反，一个函数对不同的类型具有不同的实现，相当于重载；它们两个都是静态的多态，在编译期就确定了函数的实现；子类型多态多用于面向对象语言，是动态多态，函数的具体实现在运行时才确定。动态的多态需要在运行时查表，占用的空间较多，而静多态是一种零成本抽象。</p>
<h2 id="Rust类型系统"><a href="#Rust类型系统" class="headerlink" title="Rust类型系统"></a>Rust类型系统</h2><p>Rust的类型系统将类型分为两个大类：可以在编译期确定大小的类型，还有动态大小的类型。</p>
<h3 id="动态大小类型"><a href="#动态大小类型" class="headerlink" title="动态大小类型"></a>动态大小类型</h3><p>动态大小的类型例如str字符串，编译器无法确定其大小，Rust是一个内存安全的语言，编译器会检查数组边界，对于这种情况，Rust提供了引用类型，&amp;str是str的切片，实际上是一种胖指针，保存了地址和大小，这样一来编译器就可以根据&amp;str中的大小信息为其在栈上开辟空间，并且str在运行时也会在堆上开辟内存空间。与str一样，数组也是动态大小类型，二者都不能作为函数的参数列表，因该改为其切片(引用)，因为里面储存着其大小信息。还有一点&amp;[T]是数组的不可变借用，只读而不可写，要想在函数内部更改原数组则要使用其可变借用&amp;mut [T]。</p>
<h3 id="静态大小类型"><a href="#静态大小类型" class="headerlink" title="静态大小类型"></a>静态大小类型</h3><ul>
<li><p>零大小类型</p>
<p>Rust支持零大小类型，比如单元类型( )，单元结构体，单元类型组成的数组等，它们的之就是其本身，运行时占用的内存大小为0，一个单元类型的在Rust中的应用是官方标准库中的<code>HashMap&lt;T,K&gt;</code>，把value的类型换成( )，就是<code>HashSet&lt;T&gt;</code>。</p>
</li>
<li><p>底类型</p>
<p>就是never类型，用 ! 表示，特点是没有值，可以转化为其他任意的类型，注意和零大小类型不同，零大小类型代表的是”空”，而底类型代表的是”无”。比如空的枚举<code>enum Xxx{}</code>，就是底类型。在运行时根本不可能存在，因为语法创建不出来它们的变量，这种类型的代码不会被执行。</p>
</li>
</ul>
<h3 id="Option类型"><a href="#Option类型" class="headerlink" title="Option类型"></a>Option类型</h3><p>Option类型时一种带有泛型参数的枚举，和模式匹配搭配使用来处理那些可能不会返回值的情况。在很多百年城语言里都存在一个特殊的指针叫做”空指针”：null，nil，None，Nothing，nullptr等，代表指向的对象为”空”，这样一个简单的东西引发的了许多错误。null在类型系统上打开了一个缺口，让编译器的类型检查在某写方面上失去了意义。</p>
<p>在Rust中，用一个枚举类型<code>Option&lt;T&gt; {...}</code>来解决这个问题。对于enum在匹配时Rust要求必须匹配”完整”，对于一个可有有无的类型Option来说，在使用它时必须用用模式模式将其中的值拆解出来，这就要求必须对可能出现的”空”的情况做出处理，从而避免了null这种空指针带来的危害。实际上这种方式在其他许多函数式的语言中早已被使用(如Scala，Haskell等)。</p>
<h3 id="Turbofish操作符"><a href="#Turbofish操作符" class="headerlink" title="Turbofish操作符"></a>Turbofish操作符</h3><p>有时需要在表达式中直接标注类型，这是需要用到Turbofish操作符</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">"1"</span>;</span><br><span class="line">    <span class="comment">//println!("&#123;&#125;", x.parse().unwrap());报错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x.parse::&lt;<span class="built_in">i32</span>&gt;().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>parse函数用于转化，是一个泛型方法，需要注明转化的类型，这是可以使用Turbofish操作符直接标注泛型；而unwrap函数是将一个Option中的值取出来，若没有，则会panic。在实际开发中尽量不要使用这个函数。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在处理高度重复的代码上，函数是把相同类型的值当作参数，而泛型是把类型当作参数。注意：当定义了一个带有泛型的类型，而不使用它时，编译会报错。Rust中的泛型属于静多态，在编译时会被单态化，也就是为每一个不同具体类型的泛型函数生成多个与其类型对应的函数。单态化的好处时性能好，没有运行时开销，但是缺点是容易造成编译之后的二进制文件膨胀。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span>&lt;T&gt;&#123;</span><br><span class="line">    age: <span class="built_in">i32</span>,</span><br><span class="line">    <span class="comment">//name: T定义却不使用泛型编译报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="comment">//let x = Test::&lt;i32&gt;&#123;age:12,name:14&#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>泛型函数，需要给泛型T约束，因为不是所有的类型都能够比较大小的，需要限制参数类型必须实现一种叫PartialOrd的trait，trait就是Rust抽象能力的核心。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::<span class="built_in">PartialOrd</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>&lt;T:<span class="built_in">PartialOrd</span>&gt;(s: T,v: T) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">if</span> s &gt; v &#123;</span><br><span class="line">        s</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> i1 = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">let</span> i2 = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, test(i1,i2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> f1 = <span class="number">0.9</span>;</span><br><span class="line">    <span class="keyword">let</span> f2 = <span class="number">1.1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, test(f1,f2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//32</span></span><br><span class="line"><span class="comment">//1.1</span></span><br></pre></td></tr></table></figure>



<h2 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h2><p>trait，意为特征，特质。用trait关键字定义，impl关键字实现，特质中可以定义方法，并支持默认实现，trait中还可以有常量，类型。接口的作用有：</p>
<ul>
<li>接口抽象。接口是对类型类型行为的统一约束</li>
<li>泛型约束。泛型的行为被trait限定在更有限的范围内</li>
<li>抽象类型。在运行时作为一种间接的抽象类型使用，动态地分发给具体的类型</li>
<li>标签trait。对类型的约束，可以直接作为一种标签使用</li>
</ul>
<p>trait就是一种Ad-hoc多态的体现。Rust中很多操作符就是通过trait实现的，比如加法，数值类型相加就是加法，字符串类型相加就是拼接。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span></span> &#123;</span><br><span class="line">    name: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">    age: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> People &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>, age: <span class="built_in">i32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> People&#123;name:name,age:age&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fn to_string(&amp;self)&#123;</span></span><br><span class="line">    <span class="comment">//     println!("my name is &#123;&#125;, &#123;&#125; years old", self.name,self.age);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> p = People::new(<span class="string">"xsd"</span>,<span class="number">14</span>);</span><br><span class="line">    <span class="keyword">impl</span> People&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">to_string</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"my name is &#123;&#125;, &#123;&#125; years old"</span>, <span class="keyword">self</span>.name,<span class="keyword">self</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p.to_string();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一句是一个宏，让结构体People自动实现std::fmt::Debug的trait，能够打印结构体实例，impl语句块是为结构体添加方法。main函数外面的impl中的new函数返回值是<strong>Self</strong>，这是Rust的关键字，用于表示当前结构体，这个函数相当于People结构体的”静态函数”，用<code>People::new(...);</code>调用，main函数里的impl为People添加的to_string方法，参数列表里有一个参数<strong>self</strong>，这也是Rust的一个关键字，表示当前People实例，这个方法相当于People的成员方法，用实例才能调用<code>实例a.to_string();</code>，它如果存在，则必须在函数列表的第一个(和Python里的方法有些类似)；<strong>self是变量，Self是类型，self，&amp;self，&amp;mut self是self: Self，self: &amp;self，self: &amp;mut self的缩写</strong>；注意这两个关键字的区别。</p>
<h3 id="孤儿规则"><a href="#孤儿规则" class="headerlink" title="孤儿规则"></a>孤儿规则</h3><p>从上面的代码可以看出，在程序运行时，Rust仍然能够为类型添加方法，这大大增强了程序的可扩展性。你甚至可以为不是你定义的类型添加方法，但是这并不是没有限制，比如你想为数值类型重载加法的方法，或者为标准库中的类型添加你自己的方法，这在编译时将会报错，因为<strong>特质和要实现此特质的类型至少有一个是在当前作用域内定义的</strong>。这叫做”<strong>孤儿规则</strong>“。</p>
<h3 id="接口抽象"><a href="#接口抽象" class="headerlink" title="接口抽象"></a>接口抽象</h3><p>trait将impl中的方法提取出来，可以供多种类型使用或者实现，是一种接口抽象方式。trait中的方法可以没有实现，作为接口供其他类型作为规范使用，也可以有默认实现。trait中定义的函数被称为”关联函数”，表示其与其他类型关联。其实上面的这段代码可以看作是为People定义了两种匿名的trait，因为没有名字，所以只能够在定义时用一次，而有有名子的trait可以重复使用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span></span>&#123;age:<span class="built_in">i32</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Duck</span></span>&#123;age:<span class="built_in">i32</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Fly</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Swim</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">swim</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Fly <span class="keyword">for</span> Duck &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"duck fly..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Swim <span class="keyword">for</span> Duck &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">swim</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"duck swim..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Swim <span class="keyword">for</span> Dog &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">swim</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"dog swim..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_static</span></span>&lt;T:Fly&gt;(s:T)&#123;</span><br><span class="line">    s.fly();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">swim_static</span></span>&lt;T:Swim&gt;(s:T)&#123;</span><br><span class="line">    s.swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_dyn</span></span>(s:&amp;Fly) &#123;</span><br><span class="line">    s.fly();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">swim_dyn</span></span>(s:&amp;Swim) &#123;</span><br><span class="line">    s.swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> dog = Dog&#123;age:<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> dog1 = Dog&#123;age:<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> duck = Duck&#123;age:<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> duck1 = Duck&#123;age:<span class="number">2</span>&#125;;</span><br><span class="line">    dog.swim();</span><br><span class="line">    duck.swim();</span><br><span class="line">    duck.fly();</span><br><span class="line"></span><br><span class="line">    swim_static::&lt;Dog&gt;(dog);</span><br><span class="line">    swim_dyn(&amp;dog1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fly_static::&lt;Duck&gt;(dog); expected struct `Duck`, found struct `Dog`</span></span><br><span class="line">    <span class="comment">//fly_dyn(&amp;dog); the trait `Fly` is not implemented for `Dog`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//swim_static::&lt;Duck&gt;(dog); expected struct `Duck`, found struct `Dog`</span></span><br><span class="line"></span><br><span class="line">    swim_static::&lt;Duck&gt;(duck);</span><br><span class="line">    swim_dyn(&amp;duck1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//dog swim...</span></span><br><span class="line"><span class="comment">//duck swim...</span></span><br><span class="line"><span class="comment">//duck fly...</span></span><br><span class="line"><span class="comment">//dog swim...</span></span><br><span class="line"><span class="comment">//dog swim...</span></span><br><span class="line"><span class="comment">//duck swim...</span></span><br><span class="line"><span class="comment">//duck swim...</span></span><br></pre></td></tr></table></figure>



<p>上面的代码定义了两个结构体：Dog和Duck，然后定义了两个特质trait，一个Fly，一个Swim，在分别为两个结构体实现特质，狗只会游泳不会飞，鸭子既会游泳又会飞，它们对Swim的swim方法的实现不同；后面的static和dyn函数，static的函数是一个泛型函数，对泛型参数的类型作出了约束，规定必须是实现了Fly或者Swim的trait的类型，然后在函数里面调用了参数实例的fly或者swim方法，这种调用方式叫做<strong>静态分发</strong>，也就是说，编译器在编译阶段就根据泛型参数的类型展开相应的代码，在生成的实际的代码中，这种抽象并不存在。而dyn函数的参数是&amp;Fly或者&amp;Swim类型，是一种动态类型，这种调用方式被称为<strong>动态分发</strong>，它会在运行时查找相应类型的方法，会带来一定的运行时开销，但是很小。</p>
<h3 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h3><p>在Rust中，类型能够相加，需要实现Add特质，下面是标准库中的Add特质的定义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Add</span></span>&lt;RHs=<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>,rhs:RHS) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Self是每个特质都有的隐式类型参数，表示当前实现此特质的类型，RHS=Self表示指定了加法的右值类型默认为当前类型Self，而type定义的Output叫做关联类型，表示函数返回值的类型。</p>
<p>标准库为u32类型实现Add特质($t是一个宏，代表u32类型)：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> Add <span class="keyword">for</span> $t &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = $t;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>,other: $t) -&gt; <span class="built_in">u32</span> &#123;<span class="keyword">self</span> + other&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实现时关联类型必须指定明确的类型。函数add的返回值可以写成u32，也可以写Self，Self::Output。</p>
<h3 id="约束泛型"><a href="#约束泛型" class="headerlink" title="约束泛型"></a>约束泛型</h3><p>有时在泛型编程中，编写的代码并不是为所有类型准备的，这是需要对泛型作出限制，，比如求集合最大值，需要集合里的元素是可以比较的，这就需要集合元素的类型是实现相关特质的，这样，特质就对泛型参数作出了限制，例如前面代码中的<strong>静态分发</strong>的函数，其泛型就要求必须是实现了Fly或者Swim的类型。除了前面静态分发的写法，泛型约束还有另一种写法：where子句。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span> &#123;</span><br><span class="line">    age: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">prt</span></span>&lt;T&gt;(x:T) -&gt; <span class="built_in">i32</span> <span class="keyword">where</span> T:<span class="built_in">Debug</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; - debug"</span>,x);</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x = Test&#123;age: <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> x = prt::&lt;Test&gt;(x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//Test &#123; age: 1 &#125; - debug</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h3 id="trait继承"><a href="#trait继承" class="headerlink" title="trait继承"></a>trait继承</h3><p>trait不能实现trait，但是可以继承trait，并且是多继承。其继承主要用于对原有trait的<strong>扩展</strong>，而不是<strong>合并</strong>多个trait的功能，一个特质继承多个特质再由一个类型实现从而使这个类型因为实现这一个子特质而同时实现多个特质，这样的目的是达不到的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Eat</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">eat</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Sleep</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sleep</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"sleep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Living</span></span>: Eat+Sleep &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">play</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"play"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test2</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Eat <span class="keyword">for</span> Test&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> Eat <span class="keyword">for</span> Test2&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> Sleep <span class="keyword">for</span> Test&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> Sleep <span class="keyword">for</span> Test2&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> &lt;T:Eat+Sleep&gt; Living <span class="keyword">for</span> T&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> t1 = Test;</span><br><span class="line">    <span class="keyword">let</span> t2 = Test2;</span><br><span class="line">    t1.eat();</span><br><span class="line">    t1.play();</span><br><span class="line">    t2.eat();</span><br><span class="line">    t2.sleep();</span><br><span class="line">    t2.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的代码结构Test和Test2都实现了吃和睡的特质，但是想要增加一个玩的特质给它们，假如需要扩展的类型不止两个，而是很多个，它们都实现了吃和睡这两个特质，在增加一个特质然后一个个地让那些要扩展的临类型实现新特质太过麻烦，所以采取了新的玩特质继承了吃特质和睡特质，然后为所有实现吃和睡特质的泛型都实现新特质，这样更加方便，并且原有代码不受影响，这才是特质继承的正确用法，不应该用面向对象语言里的继承去理解trait的继承。</p>
<p>从这里看出，Rust虽然不是面向对象语言，没有类，但是通过结构+特质的方式实现了面向对象的编程范式。并且其哲学是<strong>组合优于继承</strong>，传统的类的继承方式的面向对象使得代码的耦合度过高，对于代码的扩展和维护影响很大。其实不仅是Rust，现在的趋势越来越偏向于组合而不是继承，Go语言也没有类的概念，通过结构体和接口的方式实现了对面向对象的支持。继承使得代码笨重，而组合使得代码更加灵活。</p>
<h4 id="同名函数"><a href="#同名函数" class="headerlink" title="同名函数"></a>同名函数</h4><p>当一个结构体实现了多个特质，但是其中有函数同名的情况时，这时要用完整的方式调用函数，避免歧义。<strong>并且必须显式地手动传入参数self</strong>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">T1</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"T1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">T2</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"T2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">One</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> T1 <span class="keyword">for</span> One&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> T2 <span class="keyword">for</span> One&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x = One;</span><br><span class="line">    &lt;T1&gt;::test(&amp;x);</span><br><span class="line">    &lt;T2&gt;::test(&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抽象类型"><a href="#抽象类型" class="headerlink" title="抽象类型"></a>抽象类型</h3><p>静态分发就是特质对泛型的约束，而动态分发是特质对类型的抽象，如果说一个具体类型的所有可能的取值组成了这个类型，那么一群具有某些共同点的类型就组成了一种抽象类型。抽象类型无法在编译期直到其类型的大小，所以<strong>不能够直接以抽象类型作为局部变量的类型</strong>。在<strong>动态分发</strong>中，参数采用了抽象类型的引用来约束参数类型，因为抽象类型的引用是一个胖指针，类型的大小是可以确定的，其中包含了两个指针：data指针和vtable指针。以前面的实现Swim特质的Dog结构体为例，其Swim引用中包含了指向结构体实例的指针和指向Dog实现的Swim特质的<strong>虚表</strong>指针。在编译期，编译器知道胖指针的大小，但是不知道要调用哪个方法；在运行期间，当通过其引用调用该实例的方法时，系统会根据引用中的虚表指针在其序表内找到正确的函数指针，然后进行动态调用，这就是动态分发的原理。</p>
<p><strong>impl trait</strong>，可以静态分发的抽象类型，那前面的Duck为例，鸭子实现了飞和游泳的特质，可以将静态分发的函数的参数和返回值改为impl trait形式，静态抽象类型。这样使得代码简洁许多。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">static_impl</span></span>(s: <span class="keyword">impl</span> Fly+Swim) -&gt; <span class="keyword">impl</span> Fly+Swim &#123;</span><br><span class="line">    s.fly();</span><br><span class="line">    s.swim();</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> duck = Duck&#123;age:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> duck = static_impl(duck);</span><br></pre></td></tr></table></figure>

<h4 id="trait别名"><a href="#trait别名" class="headerlink" title="trait别名"></a>trait别名</h4><p>当使用一些复杂的特质时，每次使用都要带上一堆关于这个特质的类型参数，这时可以给指定参数的该特质取一个别名，方面使用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Service</span></span> &#123; </span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Request</span></span>; </span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Response</span></span>; </span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Error</span></span>; </span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Future</span></span>: Future&lt;Item=Self::Response, Error=Self::Error&gt;; </span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>, req : Self::Request) -&gt; Self::Future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HttpService</span></span> = Service&lt;Request = http::Request, </span><br><span class="line">	Response= http::Response, </span><br><span class="line">	Error= http::Error&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="标签trait"><a href="#标签trait" class="headerlink" title="标签trait"></a>标签trait</h3><p><code>#[derive(Copy, Clone, Default, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]</code></p>
<p>Rust标准库中内置了许多特质，它们有的作为”标签”来标识一个”对象”，比如实现了Debug特质的类型才能被Debug打印，而derive可以自动帮我们在指定的类型实现我们指定的部分Rust内置特质。</p>
<ul>
<li><p>Display和Debug</p>
<p>实现了Display特质的类型才能被”{}”打印出来，实现了Debug特质的类型才能被”{:?}”打印出来</p>
</li>
<li><p>PartialEq和Eq</p>
<p>使得实现的类型可以比较</p>
</li>
<li><p>Sized</p>
<p>用来标识编译期可以确定大小的类型</p>
</li>
<li><p>Usize</p>
<p>用来标识动态大小的类型</p>
</li>
<li><p>Copy</p>
<p>用于标识可以安全地按位复制其值的类型</p>
</li>
<li><p>Send</p>
<p>标识可以跨越线程安全通信的类型</p>
</li>
<li><p>Sync</p>
<p>用来标识可以在线程间安全共享引用的类型</p>
</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="as操作符"><a href="#as操作符" class="headerlink" title="as操作符"></a>as操作符</h4><ul>
<li>as操作符用于转换基本数据类型，不支持重载，”长类型”转换为”短类型”会做截断处理。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x = std::<span class="built_in">u32</span>::MAX;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">    <span class="keyword">let</span> x = x <span class="keyword">as</span> <span class="built_in">u16</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = -<span class="number">1i32</span>;</span><br><span class="line">    <span class="keyword">let</span> x = x <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//4294967295</span></span><br><span class="line"><span class="comment">//65535</span></span><br><span class="line"><span class="comment">//4294967295</span></span><br></pre></td></tr></table></figure>

<ul>
<li>as操作符还可以用于子类型的转化，这里的子类型并不是指面向对象中的子类的概念，而是同一类型不同生命周期的子类型。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"xsd"</span>;</span><br><span class="line">    <span class="keyword">let</span> x: &amp;<span class="built_in">str</span> = x <span class="keyword">as</span> &amp;<span class="built_in">str</span>;</span><br><span class="line">    <span class="keyword">let</span> x: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = x <span class="keyword">as</span> &amp;<span class="symbol">'static</span> <span class="built_in">str</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="From和Info"><a href="#From和Info" class="headerlink" title="From和Info"></a>From和Info</h4><p>From和Info是两个Rust内置的特质，用于转化自定义类型，二者互为反操作。对于类型T，如果T实现了<code>From&lt;U&gt;</code>，则可以通过T::from(u)将一个U类型的实例转化为T类型。而如果类型T实现了<code>Info&lt;U&gt;</code>，则可以通过T的实例的info方法将自身转化为U类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">From</span></span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(T) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Info</span></span>&lt;U&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">info</span></span>(<span class="keyword">self</span>) -&gt; U;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在标准库中有这样一条实现：<code>impl&lt;T,U&gt; Info&lt;U&gt; for T where U: From&lt;T&gt;</code>，所以<strong>如果U类型实现了From&lt; T &gt;，则T类型自动实现Info&lt; U &gt;</strong>。</p>
]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust之语句和表达式</title>
    <url>/2020/03/04/Rust%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Rust语句和表达式"><a href="#Rust语句和表达式" class="headerlink" title="Rust语句和表达式"></a>Rust语句和表达式</h1><h2 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h2><p>Rust中的语法可以分为两大类：语句(Statement)和表达式(Expression)。语句是指要执行的一些操作和产生副作用的表达式，表达式主要用于计算求值。表达式总会有一个结果，所以也会有它的类型，而语句不产生值，所以类型永远是单元类型( )。语句又分为两种：声明语句和表达式语句。声明语句包括变量，函数，结构体等的声明，引入包和模块等。表达式语句是指以 ; 结尾的表达式，其结果会被舍弃并返回单元值( )。因此语句可以看作特殊的表达式。由此看出，在Rust中一切皆为表达式。</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>assert_eq!是一个宏语句，用于判断左值和右值是否相等，若不相等，则会引发恐慌。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(x:<span class="built_in">i32</span>, y:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum(<span class="number">2</span>,<span class="number">3</span>), <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"world"</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum(<span class="number">1</span>,<span class="number">2</span>), <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"rust"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码只会打印hello和world，因为到了下面因为断言里的两个值不相等，所以引发线程恐慌导致退出。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>大多数语言的表达式的运算符都几乎一样，Rust也是，所以这里没必要在重新一一列举，值需要注意不同的地方即可。</p>
<ul>
<li><p>在Rust中没有++，–等等此类的运算符</p>
</li>
<li><p>在Rust里<strong>逻辑非</strong>和<strong>按位取反</strong>的运算符都是<strong>!</strong>，运算的值的类型是数字类型就是按位取反，是布尔类型就是逻辑非。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">u8</span> = <span class="number">0b_1011_1101</span>;</span><br><span class="line">    <span class="keyword">let</span> y: <span class="built_in">bool</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:0b&#125;"</span>, !x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,!y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//1000010</span></span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>布尔类型既支持逻辑与和逻辑或，又支持按位与和按位或，区别在于逻辑与和逻辑或局部恩爱“短路”功能，而按位与和按位或不具备</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">t</span></span>() -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"t call .. "</span>);</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>() -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"f call "</span>);</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;\n"</span>, t() &amp;&amp; f());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;\n"</span>, t() &amp; f());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;\n"</span>,t() || f());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;\n"</span>,t() | f() );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//t call .. f call false</span></span><br><span class="line"><span class="comment">//t call .. f call false</span></span><br><span class="line"><span class="comment">//t call .. true</span></span><br><span class="line"><span class="comment">//t call .. f call true</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在执行主函数的第三条打印语句中逻辑或，前面一个函数返回true，后面一个函数不再执行，而按位或则无论如何都会将两个函数都执行逆个。</p>
<h3 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h3><p>在Rust中，赋值表达式的类型是单元类型( )，值为( )，所以在Rust中连续赋值会出现意想不到的错误，如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> c = a = b;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;,&#123;:?&#125;"</span>, a,b,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//2,2,()</span></span><br></pre></td></tr></table></figure>

<p><code>a = b</code>赋值语句的值为( )，将其赋给了c，所以c的值为( )，而不是2。在Rust中连续比较和连续赋值都是不被支持的。因为这并不会给性能带来提升，相反会带来一些问题。</p>
<h3 id="语句块表达式"><a href="#语句块表达式" class="headerlink" title="语句块表达式"></a>语句块表达式</h3><p>在Rust中语句块，或者叫代码块也是表达式，它的最后一条语句或者表达式就是这个语句块的类型和值，函数体也是语句块，所以函数也是一个表达式，函数体最后一条语句或者表达式就是函数的返回值及类型(这一点在Scala和Go中也是这样，很多函数式语言都有此特性)。</p>
<h3 id="if-else表达式"><a href="#if-else表达式" class="headerlink" title="if-else表达式"></a>if-else表达式</h3><p>if-else是语句也可以是表达式，注意，在Rust中if和else后面的语句块必须都用<code>{}</code>包裹起来，不能向C语言那样省略。if-else作为表达式，分支部分的值的类型必须相同。if和else if的条件表达式不需要加小括号。正因为if-else的功能代替了三元表达式，所以在Rust中没有三元表达式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x&lt;<span class="number">3</span> &#123;</span><br><span class="line">        <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, test(<span class="number">1</span>),test(<span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这段代码会编译出错，因为没有else分支，即else分支类型为( )，而函数参数类型为i32，改成下面这样编译就会通过</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x&lt;<span class="number">3</span> &#123;</span><br><span class="line">        <span class="number">4</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, test(<span class="number">1</span>),test(<span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>Rust也有loop，while和for循环，以及循环控制语句break和continue，在多层嵌套循环中，可以在循环体的前面加上“生命周期标识符”，用break和continue就可以跳到指定标识符的循环。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="symbol">'a</span> : <span class="keyword">loop</span> &#123;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="symbol">'b</span> : <span class="keyword">loop</span> &#123;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">5</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">'a</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> j &gt;<span class="number">5</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">'b</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"i=&#123;&#125;,j=&#123;&#125;"</span>, i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loop语句也可以作为表达式</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">loop</span>&#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="number">4</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">loop</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>loop和while true的区别，loop是一种一定会执行的语句块，所以可以作为表达式，而while视作不一定会执行，即使条件就是true，所以不能作为表达式。</p>
</li>
<li><p>for循环，Rust中没有类似C语言中的三段式的for循环，只有for-each形式的for循环</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="comment">//数组是不可迭代的，要转化成切片</span></span><br><span class="line">    <span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//或者let array = &amp;[1,2,3,4,5];</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;array &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的定义以关键字fn开头，有一系列参数和一个返回值；函数的函数体就是一个表达式，所以函数的返回值就是其函数体这个表达式的值，函数体最后一个表达式和或者语句就是其返回值，当然Rust也支持return语句返回；函数的参数列表也支持模式结构。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test1</span></span>((x,y):(<span class="built_in">i32</span>,<span class="built_in">i32</span>)) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test2</span></span>(t:(<span class="built_in">i32</span>,<span class="built_in">i32</span>)) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="number">0</span>+t.<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test3</span></span>(x:<span class="built_in">i32</span>, y:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"result1:&#123;&#125;,result2:&#123;&#125;,result3:&#123;&#125;"</span>, test1((<span class="number">1</span>,<span class="number">2</span>)),test2((<span class="number">2</span>,<span class="number">3</span>)),test3(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//result1:3,result2:5,result3:3</span></span><br></pre></td></tr></table></figure>



<p>上面代码中的函数test1用到了模式结构，效果和函数test2相同，它们都是只有一个参数，是一个元组，而test3有两个参数。</p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>每一个函数都是独一无二的类型，即使它们的参数列表和返回值都一样，当一个函数类型的可变变量被重新赋值为另一个函数时，会出现编译报错，这是因为它们的类型不同，当两个函数的参数和返回值都相同时，可以先转化为通用函数类型在赋值，当<strong>二者参数和返回值不一样时不能转化</strong>。</p>
<ul>
<li>不能赋值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test1</span></span>(x:<span class="built_in">i32</span>, y:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test2</span></span>(x:<span class="built_in">i32</span>, y:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x-y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> fn1 = test1;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> fn2 = fn1;</span><br><span class="line"></span><br><span class="line">    fn2 = test2;<span class="comment">//报错，类型不同，不能赋值</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, fn2(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将变量转化为通用函数类型，两种写法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test1</span></span>(x:<span class="built_in">i32</span>, y:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test2</span></span>(x:<span class="built_in">i32</span>, y:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x-y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> fn1 = test1 <span class="keyword">as</span> <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>,<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>;<span class="comment">//在这里将test1转换为通用函数类型，这样变量fn1因为类型                                           // 推导而为通用函数类型</span></span><br><span class="line">    <span class="comment">//let mut fn2: fn(i32,i32) -&gt; i32 = fn1;直接显式指定变量为通用函数类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> fn2 = fn1;</span><br><span class="line"></span><br><span class="line">    fn2 = test2;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, fn2(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在函数内部可以定义任何类型：变量，静态变量，常量，函数，trait，类型等。</li>
</ul>
<h3 id="发散函数"><a href="#发散函数" class="headerlink" title="发散函数"></a>发散函数</h3><p>返回值为<strong>!</strong>的函数为发散函数，发散函数可以被转化为任意类型，并且其后面的代码都不会执行。</p>
<h3 id="const函数"><a href="#const函数" class="headerlink" title="const函数"></a>const函数</h3><p>用const修饰的函数可以在编译时期执行，并返回一个值给常量左初始化，但是const函数并不是能够使用其他普通函数可以使用的所有语句和表达式。</p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>模式匹配。有的书籍也叫模式解构，Rust中用match表达式使用了模式匹配，效果和C语言中的switch语句类似(准确的说是和if-else if效果类似)，但是要强大许多(在其他语言中也很常见，如Scala)，match分支，左边是模式，模式匹配整体也是一个表达式。在Rust中，除了match表达式，let绑定，函数参数，for循环等很多地方都采用了模式匹配。</p>
<h3 id="let绑定语句的模式匹配"><a href="#let绑定语句的模式匹配" class="headerlink" title="let绑定语句的模式匹配"></a>let绑定语句的模式匹配</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T1</span></span> (<span class="built_in">i32</span>,<span class="built_in">char</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    item1: T1,</span><br><span class="line">    item2: <span class="built_in">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x = T &#123;</span><br><span class="line">        item1:T1(<span class="number">3</span>,<span class="string">'p'</span>),</span><br><span class="line">        item2:<span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//解构</span></span><br><span class="line">    <span class="keyword">let</span> T&#123;</span><br><span class="line">        item1:T1(x,y),</span><br><span class="line">        item2:z</span><br><span class="line">    &#125; = x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x=&#123;&#125;,y=&#123;&#125;,z=&#123;&#125;"</span>, x,y,z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="match表达式"><a href="#match表达式" class="headerlink" title="match表达式"></a>match表达式</h3><p>match表达式只会匹配一个模式执行代码，一般用 _ 来表示不能匹配的默认情况，和switch中的default作用类似；当模式后面对应的代码只有一句时，可以不用大括号包裹，用 , 结尾即可。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test1</span></span>(x:<span class="built_in">i32</span>)&#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">"x is 0"</span>),</span><br><span class="line">        <span class="number">1</span>..=<span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"x in 1...3"</span>),</span><br><span class="line">        <span class="number">5</span> | <span class="number">7</span> | <span class="number">9</span> =&gt; <span class="built_in">println!</span>(<span class="string">"x is other"</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"?"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test2</span></span>(x:<span class="built_in">char</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="string">'a'</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"good!"</span>);</span><br><span class="line">            <span class="number">90</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">'b'</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"well"</span>);</span><br><span class="line">            <span class="number">70</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">'c'</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"ok"</span>);</span><br><span class="line">            <span class="number">60</span></span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"no"</span>);</span><br><span class="line">            <span class="number">50</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    test1(<span class="number">0</span>);</span><br><span class="line">    test1(<span class="number">2</span>);</span><br><span class="line">    test1(<span class="number">9</span>);</span><br><span class="line">    test1(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> x = test2(<span class="string">'c'</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x=&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//x is 0</span></span><br><span class="line"><span class="comment">//x in 1...3</span></span><br><span class="line"><span class="comment">//x is other</span></span><br><span class="line"><span class="comment">//?</span></span><br><span class="line"><span class="comment">//ok</span></span><br><span class="line"><span class="comment">//x=60</span></span><br></pre></td></tr></table></figure>

<h3 id="Guards-守卫"><a href="#Guards-守卫" class="headerlink" title="Guards(守卫)"></a>Guards(守卫)</h3><p>可以在match的各个模式中定义变量，还可以加上守卫来判断模式对应的代码是否执行。注意此时即使模式把所有的情况都罗列出来，由于编译器的限制，还是需要增加一个默认的模式，可以使用<code>unreachable!()</code>，无操作，来占位。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test3</span></span>(x:<span class="built_in">i32</span>)&#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        i <span class="keyword">if</span> i&gt;<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"i=&#123;&#125;,i &gt;= 5"</span>,i),</span><br><span class="line">        i <span class="keyword">if</span> i&lt;=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"i=&#123;&#125;,i &lt;= 5"</span>,i),</span><br><span class="line">        _ =&gt; <span class="built_in">unreachable!</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    test3(x);</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">7</span>;</span><br><span class="line">    test3(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//i=5,i &lt;= 5</span></span><br><span class="line"><span class="comment">//i=7,i &gt;= 5</span></span><br></pre></td></tr></table></figure>



<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线不仅内容能狗狗用在match语句中，还能能用在其他模式匹配中，比如在对元组等复杂数据类型解构时，想要忽略其中的一个或者一些值，就可以用下划线接收。在Rust中单独的下划线就相当与关键字，不应该用它单独作为变量或者类型的名字。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> n = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'a'</span>);</span><br><span class="line">    <span class="comment">//想要省略一个</span></span><br><span class="line">    <span class="keyword">let</span> (x,_,y,z) = n;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x=&#123;&#125;,y=&#123;&#125;,z=&#123;&#125;"</span>, x,y,z);</span><br><span class="line">    <span class="comment">//想要省略多个</span></span><br><span class="line">    <span class="keyword">let</span> (_,x,_,_) = n;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x=&#123;&#125;"</span>, x);</span><br><span class="line">    <span class="comment">//只想要第一个</span></span><br><span class="line">    <span class="keyword">let</span> (x,..) = n;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x=&#123;&#125;"</span>, x);</span><br><span class="line">    <span class="comment">//只想要第一个和最后一个</span></span><br><span class="line">    <span class="keyword">let</span> (x,..,y) = n;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x=&#123;&#125;,y=&#123;&#125;"</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//x=1,y=3,z=a</span></span><br><span class="line"><span class="comment">//x=2</span></span><br><span class="line"><span class="comment">//x=1</span></span><br><span class="line"><span class="comment">//x=1,y=a</span></span><br></pre></td></tr></table></figure>

<h3 id="if-let和while-let表达式"><a href="#if-let和while-let表达式" class="headerlink" title="if-let和while-let表达式"></a>if-let和while-let表达式</h3><p>当只对其中一种模式感兴趣，其他模式不关心的时候，使用match表达式可能会泰国麻烦，这时可以使用if-let表达式，它是match表达式的一种语法糖，相当与只有两个模式，一个是指定条件的模式，另一个是默认的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">2</span> | <span class="number">3</span> = x &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"2 or 3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">3</span> = x &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"x is 3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">5</span> = x &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"x is 5"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"x not 5"</span>, );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//2 or 3</span></span><br><span class="line"><span class="comment">//x not 5</span></span><br></pre></td></tr></table></figure>

<p>当需要在循环中对每一个集合中的元素进行模式匹配时，可以采用while-let表达式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> v.pop() &#123;</span><br><span class="line">            <span class="literal">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x),</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(x) = v.pop() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的两中方式效果是一样的，都是依次取出集合元素并输出直到集合为空时停止循环</span></span><br><span class="line"><span class="comment">//pop函数取出来的是一个Option里面如果有元素就是Some(元素)，若没有，就是None</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust复合数据类型</title>
    <url>/2020/02/25/Rust%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Rust复合数据类型"><a href="#Rust复合数据类型" class="headerlink" title="Rust复合数据类型"></a>Rust复合数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组(Array)是Rust内建的原始集合类型，数组的特点为：大小固定，元素类型相同，默认不可变。数组的类型签名为<strong>[T;N]</strong>，T是泛型，N是数组长度，N是一个编译时常量，必须在编译时确定其值。在Rust中，当数组的T和N都一样时，数组的类型才是相同的。同类型的数组之间才能相互赋值，需要注意的是，数组和指针不能隐式转换，数组在传递的时候是值传递，将复制一份数组的副本，并不是传递指针。编译器会检查是否下标越界，如果发生越界，程序会panic，立即退出。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a: [<span class="built_in">i32</span>;<span class="number">3</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> b: [<span class="built_in">i32</span>;<span class="number">3</span>] = a;</span><br><span class="line">    a[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, a.len());<span class="comment">//len方法用于获取数组长度</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,b&gt;a);<span class="comment">//true</span></span><br><span class="line">    <span class="keyword">let</span> a2 = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]];<span class="comment">//多维数组</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, a2);</span><br><span class="line">    <span class="keyword">let</span> a2 = [<span class="number">3_i32</span>,<span class="number">4</span>];<span class="comment">//创建元素相同的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是对一个数组的引用片段，是已经存在的变量的一部分，切片有两种类型：&amp;[T]和&amp;mut [T]，数组的指针类型是&amp;[T;N]或者&amp;mut [T;N]，占8位，和一个指针相同，而数组的切片的类型为&amp;[T]或者&amp;mut [T]，占了16位，切片本质上还是指针类型，数组的指针类型可以自动转化为切片类型，为什么切片类型占了16位，其实它是一个胖指针，有两个指针，一个指向数组的地址，一个指向数组或切片的长度。注意：<strong>数组不能直接迭代，切片可以</strong>。由于Rust在索引操作时会执行检查，频繁的使用索引访问会降低效率，所以推荐使用迭代器的方式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mut_array</span></span>(a: &amp;<span class="keyword">mut</span>[<span class="built_in">i32</span>])&#123;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&amp;mut:&#123;:?&#125;"</span>, std::mem::size_of::&lt;&amp;[<span class="built_in">i32</span>;<span class="number">3</span>]&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&amp;:&#123;:?&#125;"</span>, std::mem::size_of::&lt;&amp;[<span class="built_in">i32</span>]&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a: [<span class="built_in">i32</span>;<span class="number">3</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> s: &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>;<span class="number">3</span>] = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">        mut_array(s);<span class="comment">//数组指针自动转化成对应的切片类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>范围(Range)类型，有左开右闭区间和全闭区间两种，例如<code>1..5</code>是<code>std::ops::Range</code>的实例，<code>1..=5</code>是<code>std::ops::RangeInclusive</code>的实例，<code>..</code>和<code>。。=</code>是语法糖，范围类型可以直接用for in迭代，范围区间最常用的地方就是用于数组切片：<code>&amp;array[1..]</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="comment">//let a = 1..5;和下面的写法等价</span></span><br><span class="line">    <span class="keyword">let</span> a = std::ops::Range&#123;start:<span class="number">1</span>,end:<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//let b = 1..=5;和下面的写法等价</span></span><br><span class="line">    <span class="keyword">let</span> b = std::ops::RangeInclusive::new(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, &amp;array[<span class="number">2</span>..]);<span class="comment">//范围用于数组切片</span></span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> b &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//1..5</span></span><br><span class="line"><span class="comment">//1..=5</span></span><br><span class="line"><span class="comment">//[3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//5</span></span><br></pre></td></tr></table></figure>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Rust中有两种类型的字符串：&amp;str和String。&amp;str是Rust的核心内置的字符串类型，而String是标准库中的一个结构。</p>
<h3 id="amp-str"><a href="#amp-str" class="headerlink" title="&amp;str"></a>&amp;str</h3><p>&amp;str，即字符串切片，在编译时就确定其长度，不可更改，因为在Rust里的char类型是4个字节，所以字符串并不能认为是char数组，而更接近u8数组。字符串的字面量也是&amp;str，但是准确说是静态类型，就和静态变量一样是全局的。&amp;str有两个函数<code>as_ptr()</code>和<code>len()</code>可以的到其指针和长度，由此可见，&amp;str也是一个胖指针；由于UTF-8是变长编码，所以无法通过索引获取其中一个字符，要想通过索引获得单个字符需要<code>s.chars().nth(index)</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">let</span> s2: &amp;<span class="built_in">str</span> = s1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, s1,s2);</span><br><span class="line">    <span class="keyword">let</span> p: *<span class="keyword">const</span> <span class="built_in">u8</span> = s2.as_ptr();<span class="comment">//指针为const u8类型</span></span><br><span class="line">    <span class="keyword">let</span> l = s2.len();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p=&#123;:?&#125;,l=&#123;&#125;"</span>,p,l);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, s1.chars().nth(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,*p);<span class="comment">//操作原生指针需要unsafe代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//hello,hello</span></span><br><span class="line"><span class="comment">//p=0x477060,l=5</span></span><br><span class="line"><span class="comment">//Some('e')</span></span><br><span class="line"><span class="comment">//104</span></span><br></pre></td></tr></table></figure>



<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String和&amp;str最大的区别在于String拥有管理内存空间的权力，但是&amp;str只是对一块字符串区间的借用，对指向的内存空间没有所有权。String的内存空间是在堆上动态分配的，它有权扩容，&amp;String可以被自动转换为&amp;str类型。<code>let s = String::from(&quot;Hello&quot;);</code></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Rust是支持函数式编程的语言，函数是一等公民，可以作为参数和返回值。</p>
<p>定义一个函数用<strong>fn</strong>关键字，定义函数的形式为：<code>fn function_name(a:T, b:T...) -&gt;T{...}</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(a:<span class="built_in">i32</span>, b:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sub</span></span>(a:<span class="built_in">i32</span>, b:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    a-b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">op</span></span>(f:<span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>)-&gt;<span class="built_in">i32</span>, a:<span class="built_in">i32</span>, b:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    f(a,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">num</span></span>() -&gt; <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">npp</span></span>(x:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        x+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    npp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> r1 = op(add,a,b);</span><br><span class="line">    <span class="keyword">let</span> r2 = op(sub,a,b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r1=&#123;&#125;,r2=&#123;&#125;"</span>, r1,r2);</span><br><span class="line">    <span class="keyword">let</span> f = num();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, f(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//r1=14,r2=4</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，Rust对语句和表达式有着严格的区别，函数体中最后一句就是函数的返回值，如果函数有返回值，最后一句必须是表达式，即不能加；，应为加上；即被视为语句(除非是return语句)，语句是没有结果的，这会导致编译不通过，所以当函数有返回值时，最后一句末尾不要加；</strong>。</p>
<h2 id="异构数据类型"><a href="#异构数据类型" class="headerlink" title="异构数据类型"></a>异构数据类型</h2><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组(Tuple)是一种异构有限序列，异构就是指元组内的元素类型可以不同，元组的长度也是固定的，和数组一样，访问元组可以向和数组那样通过索引或者通过let结构元素(匹配模式)，利用元组可以是函数返回多个值。当元组没有元素时，表示为()，这样的元组有一个特殊的名字叫做unit(单元类型)，其占用的内存空间为0；当元组中只有一个元素时，应当在元素后加上,以区分括号表达式(和Python一样)。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">max_and_min</span></span>(a:<span class="built_in">i32</span>, b:<span class="built_in">i32</span>, c:<span class="built_in">i32</span>) -&gt; (<span class="built_in">i32</span>,<span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> a&gt;=b &#123;</span><br><span class="line">        <span class="keyword">if</span> a&gt;=c &#123;</span><br><span class="line">            max = a;</span><br><span class="line">            <span class="keyword">if</span> b &gt;= c &#123;</span><br><span class="line">                min = c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                min = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            max = c;</span><br><span class="line">            min = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> b &gt;= c &#123;</span><br><span class="line">            max = b;</span><br><span class="line">            <span class="keyword">if</span> a &gt;= c &#123;</span><br><span class="line">                min = c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                min = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            max = c;</span><br><span class="line">            min = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (max,min)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> result = max_and_min(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, result);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>, result.<span class="number">0</span>,result.<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> (max,min) = result;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"max=&#123;&#125;,min=&#123;&#125;"</span>, max,min);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, ());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,(<span class="number">0</span>,));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//(3, 1)</span></span><br><span class="line"><span class="comment">//3,1</span></span><br><span class="line"><span class="comment">//max=3,min=1</span></span><br><span class="line"><span class="comment">//()</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//(0,)</span></span><br></pre></td></tr></table></figure>



<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="具名结构体"><a href="#具名结构体" class="headerlink" title="具名结构体"></a>具名结构体</h4><p>结构体与元组类似，但是其中的每一个元素都有自己的名字。因为不能类型推导，所以每个元素的类型必须显式指定；结构体命名需遵循大驼峰命名法，不然编译器会给出警告；结构体成员用结构体实例.元素名来访问。也可以用匹配模式来访问元素。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug,PartialEq)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name : &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,<span class="comment">//静态类型</span></span><br><span class="line">    age : <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Person &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name:&amp;<span class="symbol">'static</span> <span class="built_in">str</span>, age: <span class="built_in">i32</span>) -&gt; <span class="keyword">Self</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Person&#123;name:name,age:age&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_age</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_name</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,name:&amp;<span class="symbol">'static</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="comment">//let p = Person&#123;name:"xsd", age:14&#125;;</span></span><br><span class="line">    <span class="keyword">let</span> p = Person::new(<span class="string">"xsd"</span>,<span class="number">14</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name=&#123;&#125;,age=&#123;&#125;"</span>, p.name,p.age);</span><br><span class="line">    <span class="keyword">let</span> Person&#123;name:x, age:y&#125; = p;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x=&#123;&#125;,y=&#123;&#125;"</span>,x,y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, p.get_age());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>impl代码块将定义在代码块之中的函数变成了结构体的方法，和GO实现面向对象的方式有些类似；注意：当方法参数有self时，用实例.方法名来调用方法，当参数里没有self时用结构体::方法名来调用方法，上面的代码中的new方法模拟了其他面向对象语言中的构造器。</p>
<p>当有局部变量与结构体的元素同名同类型时，在用局部变量给结构体的实例初始化时，可以不用加上元素名和冒号，当使用匹配模式访问元素时，若用与结构体元素同名的变量接收时，也可以省略。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    name: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">    age: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"xsd"</span>;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">let</span> p = Person&#123;name,age&#125;;<span class="comment">//初始化时简写</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> Person&#123;name,age&#125; = p;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name=&#123;&#125;,age=&#123;&#125;"</span>, name,age);<span class="comment">//匹配模式时简写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h4><p>元组结构体元素只有类型没有名字，和元素一样用下标来访问元素，就像有名字的元组。当元组结构体中只有一个元素时，这时称之为New Type模式。相当于把原有的类型包装成了一个新的类型，这和用type起别名不同，这是相当于创造了一种新类型，比如你可以给i32包装成Integer类型，然后给它添加一些方法。注意：<strong>定义元组结构体用的()而不是{}，并且后面要加上分号。</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyTuple</span></span>(<span class="built_in">i32</span>,&amp;<span class="symbol">'static</span> <span class="built_in">str</span>,<span class="built_in">f64</span>);</span><br><span class="line"><span class="keyword">impl</span> MyTuple &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">print_tuple</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"0:&#123;&#125;,1:&#123;&#125;,2:&#123;&#125;"</span>, <span class="keyword">self</span>.<span class="number">0</span>,<span class="keyword">self</span>.<span class="number">1</span>,<span class="keyword">self</span>.<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> t = MyTuple(<span class="number">14</span>,<span class="string">"xsd"</span>,<span class="number">99.9</span>);</span><br><span class="line">    t.print_tuple();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单元结构体"><a href="#单元结构体" class="headerlink" title="单元结构体"></a>单元结构体</h4><p>当结构体内部没有元素时，就是一个单元结构体，其定义方式为：<code>struct Empty{};</code>，单元结构体的实例就是其本身，在Debug模式下，创建的多个单元结构体的内存地址不同，但是在Release模式下，创建多个单元结构体它们会被编译器优化为一个”对象“，单元结构体主要用于一些特殊的场景。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>Rust的枚举比其他很多语言中的枚举更为强大，用<strong>enum</strong>关键字定义，Rust中有三种形式的枚举。</p>
<h3 id="无参枚举体"><a href="#无参枚举体" class="headerlink" title="无参枚举体"></a>无参枚举体</h3><p>无参枚举和C语言的枚举不同，不是数字，更没有默认值，也不能指定值，主要用于匹配模式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Level</span></span> &#123;</span><br><span class="line">    One,</span><br><span class="line">    Two,</span><br><span class="line">    Three</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> a = Level::One;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,a);<span class="comment">//One</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类C枚举体"><a href="#类C枚举体" class="headerlink" title="类C枚举体"></a>类C枚举体</h3><p>用法和c语言相同，这里的枚举体元素就有了值，可以被转换为i32类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span> &#123;</span><br><span class="line">    Red = <span class="number">0</span>,</span><br><span class="line">    Yellow = <span class="number">1</span>,</span><br><span class="line">    Blue = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> a = Color::Blue;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,a <span class="keyword">as</span> <span class="built_in">i32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//Blue</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h3 id="带参枚举体"><a href="#带参枚举体" class="headerlink" title="带参枚举体"></a>带参枚举体</h3><p>带参枚举体的枚举值带有类型参数，属于一种类型构造器，带参枚举体的枚举值本质上是函数类型。使用其枚举值就像调用函数一样。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>) -&gt; IpAddr = IpAddr::V4;</span><br><span class="line">    <span class="keyword">let</span> y = IpAddr::V6;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x(<span class="number">127</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, y(<span class="string">"xsd"</span>.to_string()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//V4(127, 0, 0, 1)</span></span><br><span class="line"><span class="comment">//V6("xsd")</span></span><br></pre></td></tr></table></figure>

<p>枚举体在Rust中是非常重要的类型，经常用于函数的返回值，表示有值和无值的情况，保证了程序的安全(在很多其他的支持函数式编程范式的语言如Scala中也有此用法)。</p>
]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust变量与基本类型</title>
    <url>/2020/02/23/Rust%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Rust之变量与基本类型"><a href="#Rust之变量与基本类型" class="headerlink" title="Rust之变量与基本类型"></a>Rust之变量与基本类型</h1><h2 id="Rust基本数据类型"><a href="#Rust基本数据类型" class="headerlink" title="Rust基本数据类型"></a>Rust基本数据类型</h2><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型(bool)是Rust内置的数据类型。bool类型只有两个值：true和false。bool类型可以被转化为数字，但是数字不能转化为bool类型。</p>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>在Rust中，用单引号定义字符类型(char)，用来表示Unicode标量值，而<strong>不是ASCII码值</strong>，<strong>占4个字节</strong>。也可以指字面量为ASCII码，这样只占一个字节，节省空间。</p>
<h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>Rust的数字类型分为三类：取值范围固定的类型，动态取值范围的类型，浮点数类型。</p>
<h4 id="固定取值范围类型"><a href="#固定取值范围类型" class="headerlink" title="固定取值范围类型"></a>固定取值范围类型</h4><p>包括无符号整数和符号整数</p>
<ul>
<li>无符号整数</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u8</td>
<td align="center">8位无符号数，占1个字节，数值范围为0~2<sup>8</sup> -1，通常用于流中的字节序列</td>
</tr>
<tr>
<td align="center">u16</td>
<td align="center">16位无符号数，占2个字节，范围0~2<sup>16</sup> -1</td>
</tr>
<tr>
<td align="center">u32</td>
<td align="center">32位无符号数，占4个字节，范围0~2<sup>32</sup> -1</td>
</tr>
<tr>
<td align="center">u64</td>
<td align="center">64位无符号数，占8个字节，范围0~2<sup>64</sup> -1</td>
</tr>
<tr>
<td align="center">u128</td>
<td align="center">128位无符号数，占16个字节，范围2<sup>128</sup> -1</td>
</tr>
</tbody></table>
<ul>
<li>符号整数</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i8</td>
<td align="center">8位有符号数，占1个字节，数值范围-2<sup>7</sup>~2<sup>7</sup> -1</td>
</tr>
<tr>
<td align="center">i16</td>
<td align="center">16位有符号数，占2个字节，数值范围-2<sup>15</sup>~2<sup>15</sup> -1</td>
</tr>
<tr>
<td align="center">i32</td>
<td align="center">32位有符号整数，占4个字节，数值范围-2<sup>31</sup>~2<sup>31</sup> -1</td>
</tr>
<tr>
<td align="center">i64</td>
<td align="center">64位有符号整数，占8个字节，数值范围-2<sup>63</sup>~2<sup>63</sup> -1</td>
</tr>
<tr>
<td align="center">i128</td>
<td align="center">128位有符号整数，占16个字节，数值范围-2<sup>127</sup>~2<sup>127</sup> -1</td>
</tr>
</tbody></table>
<h4 id="动态取值范围的整数"><a href="#动态取值范围的整数" class="headerlink" title="动态取值范围的整数"></a>动态取值范围的整数</h4><ul>
<li><strong>usize</strong>，数值范围位0 ~ 2<sup>32</sup> -1或者0 ~ 2<sup>64</sup> -1，占用4个或者8个字节，取却于机器字长</li>
<li><strong>isize</strong>，数值范围-2<sup>31</sup> ~ 2<sup>31</sup> -1或者-2<sup>63</sup> ~ 2<sup>63</sup> -1，占用4个或者8个字节，取决于机器字长</li>
</ul>
<h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>浮点类型都是有符号的，分为：</p>
<ul>
<li><strong>f32</strong>，单精度32位浮点数，至少6位有效数字，数值范围为-3.4e38~3.4e38</li>
<li><strong>f64</strong>，双精度64位浮点数，至少15位有效数字，数值范围为-1.8e308~1.8e308</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>Rust中的变量必须先声明后使用，创建变量使用<strong>let</strong>关键字，最常用的一种形式：</p>
<p><code>let a : i32 = 100;</code></p>
<p>这是Rust从函数式语言中借鉴的语法形式，称之为绑定，表明了标识符和值之间建立的一种关联关系。变量名的后面是冒号。冒号的后面是类型，因为Rust编译器具有类型推断的能力(现在比较新的静态语言好像都有这个)，所以也可以省略类型：<code>let a = 100;</code>(好像具有类型推导的语言类型都放在后面)。</p>
<p>在Rust中声明的变量默认都是不可变的(只读的)，对不可变变量再次赋值会发生编译错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line">    a = <span class="number">101</span>;<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>要想使用可变的变量，要使用<strong>mut</strong>关键字：<code>let mut a = 100;</code>，这样就可以改变变量的值了。注意在这里这个变量是mut a，let和mut不是一个整体。</p>
<p>还可以依次声明多个变量：<code>let (mut a,mut b) = (1,2);</code>，在这里<code>(1,2)</code>其实是一种复合数据类型——元组，而这样的方式其实被称为解构。</p>
<p>需要注意一点，在Rust中变量必须初始化后再使用，和C语言不同，<strong>Rust中变量没有默认值</strong>。</p>
<h3 id="变量遮蔽"><a href="#变量遮蔽" class="headerlink" title="变量遮蔽"></a>变量遮蔽</h3><p>Rust和其它大部分语言有一个很大的不同，就是在Rust中的变量遮蔽实在统一代码块下仍然可以生效。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a=&#123;&#125;"</span>,a);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a=&#123;&#125;"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码完全没有问题，它只是重新声明了一个变量，只不过两者名字相同而已，后面的a已经遮蔽了前面的a，从第二个a定义开始，前一个变量无法在被访问，它被<strong>遮蔽</strong>了。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>关键字<strong>type</strong>用于给同一个类型起别名</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Age</span></span> = <span class="built_in">u32</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(x: Age, y: Age) -&gt; Age &#123;</span><br><span class="line">    x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> a : Age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> b : <span class="built_in">u32</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"result:&#123;&#125;"</span>,add(a,b)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型别名可以代替复杂的类型，简化代码，提高可读性。</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>Rust中用<strong>static</strong>关键字声明静态变量：<code>static GLOBAL : i32 = 0;</code>，静态变量的声明周期是从程序开始到程序退出，也是不可变变量，其实就是全局变量。Rust非常注重安全，所以在静态变量(或者叫全局变量)的使用上有很多限制：</p>
<ol>
<li>全局变量在声明的时候必须初始化</li>
<li>全局变量初始化时的值必须是在编译时期就可以确定的，不能是运行时才能确定的表达式，语句，函数调用</li>
<li>使用mut修饰的静态变量在使用时必须用unsafe关键字，不论是读或者写。</li>
</ol>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>Rust中用<strong>const</strong>关键字声明常量，<code>const GLOBAL: i32 = 1;</code>，因为是常量，所以不允许用mut修饰常量，常量的初始化要求也与全局变量类似，不能是运行时期确定的值或表达式，常量与全局变量最大的不同在于编译器并不一定会常量分配内存空间，常量也没有let语句的模式匹配功能。</p>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>在写字面量的时候可以在后面加上类型，并且加类型的写法有两种，还有二进制，流进制，八进制的写法。<strong>在Rust中所有的数字字面量都可以任意地添加下划线方便阅读</strong>，例如：0x_FF_FF，32_11_u32等等。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">static</span> YEAR: <span class="built_in">u32</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,YEAR);</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1_i32</span>;<span class="comment">//数字字面值的另一种写法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,num);</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">32u64</span>;<span class="comment">//也是数字字面值的另一种写法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,num);</span><br><span class="line">    <span class="keyword">let</span> f = <span class="number">9.0f32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,f);</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0b1101_1011</span>;<span class="comment">//二进制</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,num);</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0o16</span>;<span class="comment">//八进制</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,num);</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0x1A</span>;<span class="comment">//十六进制</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在定义字符型变量时，如果只用到了ASCII码，那么只用一个字节就够了，这样可以在字符字面量前面加上字母b就可以，例如定义字符‘a’，就可以<code>let x = b&#39;a&#39;;</code>，这样这个字符的类型就是u8。</li>
<li>在标准库std::f64和std::f32里都提供了IEEE所需的特殊常量值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,std::<span class="built_in">f32</span>::INFINITY);<span class="comment">//无穷大</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,std::<span class="built_in">f32</span>::NEG_INFINITY);<span class="comment">//负无穷大</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,std::<span class="built_in">f32</span>::NAN);<span class="comment">//非数值</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,std::<span class="built_in">f32</span>::MIN);<span class="comment">//最小有限值</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,std::<span class="built_in">f32</span>::MAX);<span class="comment">//最大有限值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果:</span></span><br><span class="line"><span class="comment">//inf</span></span><br><span class="line"><span class="comment">//-inf</span></span><br><span class="line"><span class="comment">//NaN</span></span><br><span class="line"><span class="comment">//-340282350000000000000000000000000000000.0</span></span><br><span class="line"><span class="comment">//340282350000000000000000000000000000000.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>整数的默认类型是i32</p>
</li>
<li><p>在Rust中可以为任意类型添加方法，例如标准库中的整数求幂方法：<code>println!(&quot;{}&quot;,2_i32.pow(3));</code></p>
</li>
</ul>
<h3 id="数值计算问题"><a href="#数值计算问题" class="headerlink" title="数值计算问题"></a>数值计算问题</h3><p>在整数的计算上，默认情况下，在debug模式下，编译器会检查溢出，一旦发生溢出会引发panic，当初在release模式下，不检查整数溢出，采取和C一样的自动舍弃高位的方式。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Rust对类型转换控制的非常严格，下面这段代码编译将会报错</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">i32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">i64</span> = a;</span><br></pre></td></tr></table></figure>

<p>i32不能直接转化成i64，这在很多的语言里很正常(隐式转化)，但是在Rust中需要用<strong>as</strong>关键字显式转化，有时甚至需要多次转化</p>
<p><code>let b: i64 = a as i64;</code></p>
<p>整数和浮点数可以用as互相转换，布尔类型可以转化为整数，而整数不能够转化为布尔类型</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> a: <span class="built_in">i32</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> b: <span class="built_in">i64</span> = a <span class="keyword">as</span> <span class="built_in">i64</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b=&#123;&#125;"</span>,b);</span><br><span class="line">    <span class="keyword">let</span> f: <span class="built_in">f64</span> = a <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"f=&#123;&#125;"</span>,f);</span><br><span class="line">    <span class="keyword">let</span> num: <span class="built_in">i64</span> = f <span class="keyword">as</span> <span class="built_in">i64</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"num=&#123;&#125;"</span>,num);</span><br><span class="line">    <span class="keyword">let</span> c: <span class="built_in">char</span> = <span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c=&#123;&#125;"</span>,c);</span><br><span class="line">    <span class="keyword">let</span> c: <span class="built_in">i32</span> = c <span class="keyword">as</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c=&#123;&#125;"</span>,c);</span><br><span class="line">    <span class="keyword">let</span> b: <span class="built_in">bool</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b=&#123;&#125;"</span>,b);</span><br><span class="line">    <span class="keyword">let</span> b = b <span class="keyword">as</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b=&#123;&#125;"</span>,b);</span><br><span class="line">    <span class="keyword">let</span> b: <span class="built_in">bool</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b=&#123;&#125;"</span>,b);</span><br><span class="line">    <span class="keyword">let</span> b = b <span class="keyword">as</span> <span class="built_in">u8</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b=&#123;&#125;"</span>,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//b=1</span></span><br><span class="line"><span class="comment">//f=1</span></span><br><span class="line"><span class="comment">//num=1</span></span><br><span class="line"><span class="comment">//c=A</span></span><br><span class="line"><span class="comment">//c=65</span></span><br><span class="line"><span class="comment">//b=true</span></span><br><span class="line"><span class="comment">//b=1</span></span><br><span class="line"><span class="comment">//b=false</span></span><br><span class="line"><span class="comment">//b=0</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust初探</title>
    <url>/2020/02/22/Rust%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="Rust初探"><a href="#Rust初探" class="headerlink" title="Rust初探"></a>Rust初探</h1><h2 id="初识Rust"><a href="#初识Rust" class="headerlink" title="初识Rust"></a>初识Rust</h2><p>Rust是由Mozilla推出的编程语言，最初听说Rust编程语言是因为它连续四年获得“最受欢迎的编程语言”的称号。但是使用Rust的人并不多，并且其以学习曲线陡峭著称，那么这样看似矛盾的现象勾起了我对Rust的好奇心，所以想了解了解这门语言。听说这门语言以取代C++为目的，被称为下一个40年使用的语言，那么它到底是一门什么样的语言？</p>
<p>在Rust的官网首页上，就描述了Rust的三个特点：高性能，可靠，高效率。而其他资料关于Rust的描述为：无GC，内存安全，线程安全，混合多种编程范式，强类型的静态的系统级语言。从其描述上看，的确有要替代C++的语言”该有的样子“。</p>
<p>系统级编程是相对于应用级编程而言，一般来说，系统级编程意味着更接近底层，为上层的应用软件提供支持，系统级编程语言一般具有以下特点：</p>
<ol>
<li>可以在资源非常受限的环境下执行；</li>
<li>运行时开销很小，非常高效；</li>
<li>很小的运行库，甚至于没有；</li>
<li>可以允许直接的内存操作。</li>
</ol>
<p>需要注意的是，这里的系统并不一定指的就是操作系统。近些年越来越多的出现的被称为“系统级”的编程语言(如：Go，Dlang，Nim等)，但是主流的系统级编程语言还是C和C++，而Rust显然定位与他们相同，都是编译型语言，无需runtime，没有GC等等，但是Rust于C/C++最大的不同是Rust虽然没有GC但是确是内存安全的，这可以说是Rust的最大特点。另外，在很多谈论Rust的时候都会谈到其一个重要的设计哲学：<strong>零成本抽象</strong>，这表明Rust除了安全，还追求高效率开发和性能。我们知道，相比于C/C++等偏底层的语言，一些较为”上层“的编程语言(如：Python，Ruby等)的开发效率更高，因为这些语言具有一定的抽象表达能力，但是这些语言的抽象表达能力大多都是靠牺牲性能换来的，而Rust的设计哲学之一就是零成本抽象，在拥有不逊于C++的性能的同时拥有提高开发效率和实用性的抽象能力。</p>
<p>关于安装配置环境和其他大多数语言没什么不同，安装一些列Rust的工具链包括Rust的编译器rustc，包管理器cargo，其他一系列的工具，还有管理更新这些工具的rustup，rustc和go一样，不仅能指出错误，还能给出改正的建议，这对新手非常友好，还有着很好的交叉编译能力。需要注意的是，如果是在Windows环境下安装配置Rust开发环境，还需要下载VS，安装Visual C++工具链。并且由于网络的关系，rust的工具链可能会下载失败，需要配置镜像或者多试几次。</p>
<h2 id="你好，世界"><a href="#你好，世界" class="headerlink" title="你好，世界"></a>你好，世界</h2><p>我们没有理由不遵循传统，从最简单的hello world开始，一开始就有两种方式，通过<code>cargo new hello_world</code>命令让cargo创建一个新项目，里面就包含有一个main.rs文件，Rust的源代码文件以<code>.rs</code>结尾，并且必需是UTF-8编码，创建了一个新的项目之后进入项目根目录下，可以用命令<code>cargo build hello_world</code>编译整个项目，也可以使用命令<code>cargo run hello_world</code>直接运行整个项目，在编译或者运行之前还可以用<code>cargo check</code>来检查项目是否可以编译，这比<code>cargo build</code>快的多。cargo作为包管理工具还可以帮我们下载依赖，当然一个简单的hello word并不需要依赖什么，所以这样做有些费事，那么就使用最原始的方式用编译器编译，然后运行。</p>
<p>新建一个名为<code>hello.rs</code>的文件，编写代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>保存退出，在命令行中进入当前路径，使用命令<code>rustc hello.rs</code>编译的到一个同名的可执行文件，运行就可以在控制台上看到打印的<code>Hello Wolrd!</code>，到这里第一个程序就完成了。</p>
<h2 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h2><p>在上面的程序中<code>println!</code>是一个宏，并不是一个函数，和C语言的<code>printf</code>函数作用类似。Rust用宏来做输出的好处是在编译时就可以对参数的个数，格式做检查，以便提早发现错误，而函数只能在运行时发现出错。这面一段代码是输出宏的一些用法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"1,2,&#123;&#125;"</span>, <span class="number">3</span>); <span class="comment">//普通用法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:o&#125;"</span>, <span class="number">16</span>); <span class="comment">//八进制</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:X&#125;"</span>, <span class="number">16</span>); <span class="comment">//十六进制，x大小写都行</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:b&#125;"</span>, <span class="number">8</span>); <span class="comment">//二进制</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, &amp;<span class="number">0</span>); <span class="comment">//指针</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:e&#125;"</span>, <span class="number">10000.3</span>); <span class="comment">//科学计数,e大小写都行</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, <span class="string">"test"</span>); <span class="comment">//打印debug</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>, (<span class="string">"test1"</span>, <span class="string">"test2"</span>)); <span class="comment">//换行打印debug</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a=&#123;a&#125;,b=&#123;b&#125;"</span>, b = <span class="number">1</span>, a = <span class="number">2</span>); <span class="comment">//命名参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码的运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, world!</span><br><span class="line">1,2,3</span><br><span class="line">20</span><br><span class="line">10</span><br><span class="line">1000</span><br><span class="line">0x4760c8</span><br><span class="line">1.00003e4</span><br><span class="line">&quot;test&quot;</span><br><span class="line">(</span><br><span class="line">    &quot;test1&quot;,</span><br><span class="line">    &quot;test2&quot;,</span><br><span class="line">)</span><br><span class="line">a&#x3D;2,b&#x3D;1</span><br></pre></td></tr></table></figure>



<p>Rust官网地址：<a href="https://www.rust-lang.org/" target="_blank" rel="noopener">https://www.rust-lang.org/</a></p>
<p>Rust标准库文档地址： <a href="https://doc.rust-lang.org/std/" target="_blank" rel="noopener">https://doc.rust-lang.org/std/</a></p>
]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
</search>
